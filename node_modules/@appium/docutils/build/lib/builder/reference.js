"use strict";
/**
 * Builds reference documentation via TypeDoc.  The output is _markdown_, intended to be imported into MkDocs.
 *
 * @module
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildReferenceDocs = exports.runTypedoc = void 0;
const support_1 = require("@appium/support");
const lodash_1 = __importDefault(require("lodash"));
const node_path_1 = __importDefault(require("node:path"));
const typedoc_1 = require("typedoc");
const constants_1 = require("../constants");
const error_1 = require("../error");
const fs_1 = require("../fs");
const logger_1 = require("../logger");
const util_1 = require("../util");
const log = (0, logger_1.getLogger)('builder:reference');
/**
 * Executes TypeDoc _in the current process_
 *
 * You will probably want to run `updateNav()` after this.
 *
 * @privateRemarks Monkeypatches TypeDoc's homebrew "glob" implementation because it is broken
 * @parma typeDocJsonPath - Path to `typedoc.json`
 * @param opts - TypeDoc options
 */
async function runTypedoc(typeDocJsonPath, opts) {
    const args = (0, util_1.argify)(opts);
    log.debug('TypeDoc args:', args);
    const app = new typedoc_1.Application();
    app.options.setValue('plugin', [
        'typedoc-plugin-markdown',
        'typedoc-plugin-resolve-crossmodule-references',
        '@appium/typedoc-plugin-appium',
    ]);
    app.options.addReader(new typedoc_1.TypeDocReader());
    app.options.addReader(new typedoc_1.ArgumentsReader(100, args));
    app.bootstrap({ options: node_path_1.default.dirname(typeDocJsonPath) });
    const out = app.options.getValue('out');
    const project = app.convert();
    if (project) {
        return await app.generateDocs(project, out);
    }
    throw new error_1.DocutilsError('TypeDoc found nothing to document. Is your package empty?');
}
exports.runTypedoc = runTypedoc;
/**
 * Mapping of whatever our log level is to whatever TypeDoc's should be.
 *
 * TypeDoc's "info" is too verbose for our needs, and it's our default, so
 * we map it to "warn".
 */
const TypeDocLogLevelMap = {
    debug: 'Verbose',
    info: 'Warn',
    warn: 'Warn',
    error: 'Error',
};
/**
 * Build reference documentation via TypeDoc
 * @param opts - Options
 */
async function buildReferenceDocs({ typedocJson: typeDocJsonPath, cwd = process.cwd(), tsconfigJson: tsconfig, logLevel = constants_1.DEFAULT_LOG_LEVEL, title, } = {}) {
    const stop = (0, util_1.stopwatch)('buildReferenceDocs');
    typeDocJsonPath = typeDocJsonPath
        ? node_path_1.default.resolve(cwd, typeDocJsonPath)
        : await (0, fs_1.findTypeDocJsonPath)(cwd);
    if (!typeDocJsonPath) {
        throw new error_1.DocutilsError(`Could not find ${constants_1.NAME_TYPEDOC_JSON} from ${cwd}; run "${constants_1.NAME_BIN}" to create it`);
    }
    const pkgRoot = support_1.fs.findRoot(cwd);
    const relativePath = (0, util_1.relative)(cwd);
    const relativeTypeDocJsonPath = relativePath(typeDocJsonPath);
    log.debug(`Using ${relativeTypeDocJsonPath} as typedoc.json`);
    let typeDocJson;
    // we only need typedoc.json to make sure we have a custom "out" path.
    try {
        typeDocJson = (0, fs_1.readTypedocJson)(typeDocJsonPath);
        log.debug('Contents of %s: %O', relativeTypeDocJsonPath, typeDocJson);
    }
    catch (err) {
        log.error(err);
        throw new error_1.DocutilsError(`Could not read ${relativeTypeDocJsonPath}; run "${constants_1.NAME_BIN} init" to create it`);
    }
    // if for some reason "out" is not in typedoc.json, we want to use our default path.
    // otherwise, typedoc's default behavior is to write to the "docs" dir, which is the same dir that
    // we use (by default) as a source dir for the mkdocs site--which might contain files under vcs.
    let out;
    if (typeDocJson.out) {
        log.debug(`Found "out" option in ${constants_1.NAME_TYPEDOC_JSON}: ${typeDocJson.out}`);
    }
    else {
        out = node_path_1.default.relative(node_path_1.default.dirname(typeDocJsonPath), node_path_1.default.join(pkgRoot, constants_1.DEFAULT_REL_TYPEDOC_OUT_PATH));
        log.debug('Setting "out" option to %s', out);
    }
    const extraTypedocOpts = lodash_1.default.pickBy({ tsconfig, name: title, out, logLevel: TypeDocLogLevelMap[logLevel] }, Boolean);
    try {
        await runTypedoc(typeDocJsonPath, extraTypedocOpts);
        const finalOut = (typeDocJson.out ?? out);
        log.success('Reference docs built at %s (%dms)', node_path_1.default.isAbsolute(finalOut) ? relativePath(finalOut) : finalOut, stop());
    }
    catch (err) {
        log.error(err);
    }
}
exports.buildReferenceDocs = buildReferenceDocs;
//# sourceMappingURL=reference.js.map