"use strict";
/**
 * Handles updating/adding the `nav` property of `mkdocs.yml`, based on the output of `typedoc`;
 * specifically, the command documentation generated by `@appium/typedoc-plugin-appium`.
 *
 * @module
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.updateNav = exports.parseNav = void 0;
const support_1 = require("@appium/support");
const lodash_1 = __importDefault(require("lodash"));
const node_path_1 = __importDefault(require("node:path"));
const constants_1 = require("../constants");
const error_1 = require("../error");
const fs_1 = require("../fs");
const logger_1 = require("../logger");
const util_1 = require("../util");
const log = (0, logger_1.getLogger)('builder:nav');
/**
 * Gets a list of `.md` files relative to `docs_dir`
 * @param targetDir Directory ostensibly containing Markdown files; must be absolute
 * @param mkDocsDocsDir The path to the `docs_dir` in the `mkdocs.yml` file; must be absolute
 * @returns List of Markdown files relative to the `docs_dir` in the `mkdocs.yml` file
 */
async function findRelativeMarkdownFiles(targetDir, mkDocsDocsDir) {
    if (!node_path_1.default.isAbsolute(targetDir)) {
        throw new error_1.DocutilsError(`Expected absolute path, got '${targetDir}'`);
    }
    if (!node_path_1.default.isAbsolute(mkDocsDocsDir)) {
        throw new error_1.DocutilsError(`Expected absolute path, got '${mkDocsDocsDir}'`);
    }
    const relDir = node_path_1.default.relative(mkDocsDocsDir, targetDir);
    const dirEnts = await support_1.fs.readdir(targetDir, { withFileTypes: true });
    return dirEnts
        .filter((ent) => ent.isFile() && ent.name.endsWith('.md'))
        .map((ent) => node_path_1.default.join(relDir, ent.name));
}
/**
 * Because the `nav` property of `mkdocs.yml` is both a recursive type and a kind of awful one, it's
 * easier to work with it if we rewrite the data into a flat array of objects. We keep a `keypath`
 * prop which represents the deep/nested location within the `nav` object.
 *
 * @privateRemarks This function is not recursive; instead it loops over a queue of items to process
 * data, and we append to that queue while processing if needed.
 * @param nav Contents of the `nav` prop of `mkdocs.yml`
 * @returns A list of objects, each with a `keypath` property and a `fileOrUrl` property (and maybe
 * a `name` property)
 */
function parseNav(nav) {
    let parsedNav = [];
    const entries = Object.entries(nav);
    const queue = [{ entries, keypath: '' }];
    while (queue.length) {
        const { entries, keypath } = queue.shift();
        for (const [key, item] of entries) {
            if (lodash_1.default.isString(item)) {
                const navData = {
                    keypath: keypath ? `${keypath}.${key}` : key,
                    fileOrUrl: item,
                };
                // if the key is not convertible to a number, it's a name
                // which was manually put there by somebody.
                if (Number.isNaN(Number(key))) {
                    navData.name = key;
                }
                parsedNav = [...parsedNav, navData];
            }
            else if (lodash_1.default.isObject(item)) {
                const subEntries = Object.entries(item);
                queue.push({ entries: subEntries, keypath: keypath ? `${keypath}.${key}` : key });
            }
        }
    }
    return parsedNav;
}
exports.parseNav = parseNav;
/**
 * Finds all items within the list of parsed nav data which correpsond to the header.  This is
 * imperfect, as it's possible for the header string to appear in multiple places in the nav, but let's just ignore that until we can't.
 * @param navData Some parsed nav data
 * @param header Header name
 */
function filterHeaderItems(navData, header) {
    return lodash_1.default.filter(navData, (item) => lodash_1.default.toPath(item.keypath).includes(header));
}
/**
 *
 * @param rootHeaderKeypath Root keypath as determined by {@linkcode getRootHeaderKeypath}
 * @param offset Numeric offset within the array of items for the header
 * @param data Any parsed nav data found. For new items, this will be `undefined`. If not new, it
 * may or may not have a `name` prop, and if it does, we want to retain it.
 * @returns Complete keypath for a nav item beginning with the root keypath
 */
function getKeypathForHeaderItem(rootHeaderKeypath, offset, data) {
    return data?.name
        ? `${rootHeaderKeypath}.${offset}.${data.name}`
        : `${rootHeaderKeypath}.${offset}`;
}
/**
 * Compares two sets of nav data and determines if they are different.
 *
 * This does not compare the entire `nav` object with a new one; it works per-header
 * @param newNavData Nav data as computed by {@linkcode getNavItemsForDir} corresponding to a
 * particular header
 * @param navData Subset of original nav data as parsed by {@linkcode parseNav}, corresponding to
 * the same header
 */
function navDataDidChange(newNavData, navData) {
    const diff = lodash_1.default.xorWith(newNavData, navData, (a, b) => a.keypath === b.keypath && a.fileOrUrl === b.fileOrUrl);
    return !lodash_1.default.isEmpty(diff);
}
/**
 * Find the "root" keypath for a particular header
 * @param headerItems Some subset of the nav data having keypaths corresponding to `header`
 * @param header Header string
 * @returns The keypath up to the header string, inclusive
 */
function getRootHeaderKeypath(headerItems, header) {
    // these are the parts of the keypath of the first item, which will contain the header string. it
    // dosn't matter whether we pick the first one or any one; they will all contain the same root
    // keypath by definition.
    const rootHeaderKeypathParts = lodash_1.default.toPath(lodash_1.default.first(headerItems).keypath);
    // this is the keypath up to the header string, inclusive.
    // we append indices or names to this keypath
    return rootHeaderKeypathParts.slice(0, rootHeaderKeypathParts.indexOf(header) + 1).join('.');
}
/**
 * This examines the `navData` looking for items matching the header string (which _may_ be defined
 * by `dir`; if `all` is true, we just use the default header, because we will be returning a whole
 * lot of headers).
 *
 *
 * @param dir Abs path to directory containing markdown files generated by TypeDoc
 * @param mkDocsDocsDir Configured `docs_dir` or via options
 * @param navData Nav data parsed by {@linkcode parseNav}
 * @param all If `true`, process all markdown files, not just commands
 */
async function getNavItemsForDir(dir, mkDocsDocsDir, navData, nav, all = false) {
    let dataChanged = false;
    const newNavHeaderItems = [];
    const referenceOutputFilepaths = await findRelativeMarkdownFiles(dir, mkDocsDocsDir);
    if (!referenceOutputFilepaths.length) {
        log.warn('No markdown files found in %s; did TypeDoc run?', dir);
        return { data: [], changed: false };
    }
    const navHeader = all ? lodash_1.default.startCase(node_path_1.default.basename(dir)) : constants_1.DEFAULT_NAV_HEADER;
    const navHeaderItems = filterHeaderItems(navData, navHeader);
    // if we found items with this header already, we are going
    // to replace them all wholesale
    if (navHeaderItems.length) {
        log.debug('Found %d item(s) in header %s', navHeaderItems.length, navHeader);
        // we append indices or names to this keypath
        const rootHeaderKeypath = getRootHeaderKeypath(navHeaderItems, navHeader);
        for (const fileOrUrl of referenceOutputFilepaths) {
            const offset = navHeaderItems.findIndex((item) => item.fileOrUrl === fileOrUrl);
            const newOffset = offset >= 0 ? offset : navHeaderItems.length;
            const data = navHeaderItems[offset];
            log.warn(rootHeaderKeypath, newOffset, data);
            const keypath = getKeypathForHeaderItem(rootHeaderKeypath, newOffset, data);
            newNavHeaderItems.push({ keypath, fileOrUrl });
        }
        // look for any differences between what we have and what's in the file
        if (navDataDidChange(newNavHeaderItems, navHeaderItems)) {
            log.debug('Will write new nav data for header %s: %O', navHeader, newNavHeaderItems);
            dataChanged = true;
        }
        else {
            log.debug('No changes for header %s', navHeader);
        }
    }
    else {
        log.debug('No items found in header %s', navHeader);
        const navOffset = nav.length;
        for (const [idx, newRefFilepath] of referenceOutputFilepaths.entries()) {
            newNavHeaderItems.push({
                keypath: `${navOffset}.${navHeader}.${idx}`,
                fileOrUrl: newRefFilepath,
            });
        }
        log.debug('Will create nav data for header %s', navHeader);
        dataChanged = true;
    }
    return { data: newNavHeaderItems, changed: dataChanged };
}
/**
 * Applies the changes in `newData` to the `mkDocsYml` object.
 *
 * **This function mutates `mkDocsYml`.**
 * @param newData New nav data
 * @param mkDocsYml Original `mkdocs.yml`
 */
function applyNavData(newData, mkDocsYml) {
    for (const { keypath, fileOrUrl } of newData) {
        lodash_1.default.set(mkDocsYml, `nav.${keypath}`, fileOrUrl);
    }
}
/**
 * Update the `nav` property of `mkdocs.yml` with a list of "command" files generated by TypeDoc via
 * `@appium/typedoc-plugin-appium`.
 *
 * To be clear, this function **modifies the MkDocs config file (`mkdocs.yml`) in place**; it is
 * typically under version control, so if this function makes any changes, you'll want to commit them.
 * @param opts - Options
 * @todo implement `dryRun` option
 */
async function updateNav({ cwd = process.cwd(), mkdocsYml: mkDocsYmlPath, typedocJson: typeDocJsonPath, all = false, } = {}) {
    // we need `mkdocs.yml` to update
    // and we need `typedoc.json` to know where to look for the command docs
    [mkDocsYmlPath, typeDocJsonPath] = await Promise.all([
        mkDocsYmlPath ?? (0, fs_1.findMkDocsYml)(cwd),
        typeDocJsonPath ?? (0, fs_1.findTypeDocJsonPath)(cwd),
    ]);
    if (!mkDocsYmlPath) {
        throw new error_1.DocutilsError(`Could not find ${constants_1.NAME_MKDOCS_YML} from ${cwd};  run "${constants_1.NAME_BIN} init" to create it`);
    }
    if (!typeDocJsonPath) {
        throw new error_1.DocutilsError(`Could not find ${constants_1.NAME_TYPEDOC_JSON} from ${cwd};  run "${constants_1.NAME_BIN} init" to create it`);
    }
    const relativePath = (0, util_1.relative)(cwd);
    const relMkDocsYmlPath = relativePath(mkDocsYmlPath);
    const typeDocJson = (0, fs_1.readTypedocJson)(typeDocJsonPath);
    const mkDocsYml = (await (0, fs_1.readYaml)(mkDocsYmlPath));
    /**
     * Absolute path to `typedoc.json`
     */
    const absTypeDocJsonPath = node_path_1.default.isAbsolute(typeDocJsonPath)
        ? typeDocJsonPath
        : node_path_1.default.resolve(cwd, typeDocJsonPath);
    /**
     * Absolute path to TypeDoc's output directory (`out`)
     */
    const typeDocOutDir = node_path_1.default.resolve(node_path_1.default.dirname(absTypeDocJsonPath), typeDocJson.out ? typeDocJson.out : constants_1.DEFAULT_REL_TYPEDOC_OUT_PATH);
    /**
     * Absolute path to `mkdocs.yml`
     */
    const absMkdocsYmlPath = node_path_1.default.isAbsolute(mkDocsYmlPath)
        ? mkDocsYmlPath
        : node_path_1.default.resolve(cwd, mkDocsYmlPath);
    const { docs_dir: docsDir, nav = [] } = mkDocsYml;
    /**
     * Absolute path to the directory containing MkDocs input docs
     */
    const mkDocsDocsDir = node_path_1.default.resolve(node_path_1.default.dirname(absMkdocsYmlPath), docsDir ?? 'docs');
    /**
     * @todo
     * `commands` is a dirname configurable via the `commandsDir` option added by
     * `@appium/typedoc-plugin-appium`. this lives in `typedoc.json`, but in order for it to be parsed
     * using TypeDoc's facilities, we have to load plugins before reading `typedoc.json`, which is
     * slow. we will probably have to support this in the future, but for now, we can just hardcode it
     */
    const dirs = all ? await (0, fs_1.findDirsIn)(typeDocOutDir) : [node_path_1.default.join(typeDocOutDir, 'commands')];
    let shouldWriteMkDocsYml = false;
    const navData = parseNav(nav);
    // this is the thing which will be assigned to the `nav` prop
    // and thus written to `mkdocs.yml` if there were any changes.
    // we don't need the `name` prop, since the name is already present in the keypath.
    const newData = [];
    for await (const dir of dirs) {
        const { data, changed } = await getNavItemsForDir(dir, mkDocsDocsDir, navData, nav, all);
        if (changed) {
            shouldWriteMkDocsYml = true;
        }
        newData.push(...data);
    }
    if (shouldWriteMkDocsYml) {
        applyNavData(newData, mkDocsYml);
        const yaml = (0, fs_1.stringifyYaml)(mkDocsYml);
        log.debug('Writing to %s:\n%s', mkDocsYmlPath, yaml);
        await (0, fs_1.safeWriteFile)(mkDocsYmlPath, yaml, true);
        log.success('Updated MkDocs navigation config for reference docs; please run "git add -A %s" and commit this change', relMkDocsYmlPath);
    }
    else {
        log.info('No changes needed for MkDocs config at %s', relMkDocsYmlPath);
    }
}
exports.updateNav = updateNav;
//# sourceMappingURL=nav.js.map