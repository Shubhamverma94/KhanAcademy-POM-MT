/**
 * A bunch of type guards. Because here is a place to put all of them.
 * @module
 */
import { DeclarationReflection, LiteralType, ParameterReflection, ReflectionType, TupleType, TypeOperatorType } from 'typedoc';
import { AppiumTypesReflection, BaseDriverDeclarationReflection, BasePluginConstructorDeclarationReflection, CallSignatureReflection, CallSignatureReflectionWithArity, ClassDeclarationReflection, CommandMethodDeclarationReflection, CommandPropDeclarationReflection, ConstructorDeclarationReflection, DeclarationReflectionWithReflectedType, ExecMethodDeclarationReflection, ExecMethodDefParamsPropDeclarationReflection, ExternalDriverDeclarationReflection, HTTPMethodDeclarationReflection, InterfaceDeclarationReflection, MethodDefParamNamesDeclarationReflection, MethodDefParamsPropDeclarationReflection, MethodMapDeclarationReflection, PropDeclarationReflection } from './converter/types';
import { AllowedHttpMethod, ExecMethodData, ParentReflection } from './model';
/**
 * Type guard for {@linkcode DeclarationReflection}
 * @param value any value
 */
export declare function isDeclarationReflection(value: any): value is DeclarationReflection;
export declare function isParentReflection(value: any): value is ParentReflection;
export declare function isAppiumTypesReflection(value: any): value is AppiumTypesReflection;
/**
 * Type guard for {@linkcode ReflectionType}
 * @param value any value
 */
export declare function isReflectionType(value: any): value is ReflectionType;
/**
 * Type guard for {@linkcode TypeOperatorType}
 * @param value any value
 */
export declare function isTypeOperatorType(value: any): value is TypeOperatorType;
/**
 * Type guard for {@linkcode LiteralType}
 * @param value any value
 */
export declare function isLiteralType(value: any): value is LiteralType;
/**
 * Type guard for {@linkcode TupleType}
 * @param value any value
 */
export declare function isTupleType(value: any): value is TupleType;
/**
 * Type guard for a {@linkcode DeclarationReflectionWithReflectedType} corresponding to
 * the `executeMethodMap` static property of an extension class.
 * @param value any
 */
export declare function isExecMethodDefReflection(value: any): value is ExecMethodDeclarationReflection;
/**
 * Type guard for a {@linkcode MethodDefParamNamesDeclarationReflection} corresponding to a list of required or optional parameters within a command or execute method definition.
 * @param value any value
 */
export declare function isMethodDefParamNamesDeclarationReflection(value: any): value is MethodDefParamNamesDeclarationReflection;
/**
 * Type guard for a {@linkcode PropDeclarationReflection} corresponding to some property of a constant object.
 * @param value any value
 */
export declare function isRoutePropDeclarationReflection(value: any): value is PropDeclarationReflection;
/**
 * Type guard for a {@linkcode BaseDriverDeclarationReflection} corresponding to the `@appium/base-driver` module (_not_ the class).
 * @param value any value
 */
export declare function isBaseDriverDeclarationReflection(value: any): value is BaseDriverDeclarationReflection;
/**
 * Type guard for a property of an object (a {@linkcode Reflection} having kind {@linkcode ReflectionKind.Property}).
 * @param value any value
 */
export declare function isPropertyKind(value: any): boolean;
/**
 * Type guard for a {@linkcode MethodMapDeclarationReflection} corresponding to the `newMethodMap` static property of an extension class _or_ the `METHOD_MAP` export within `@appium/base-driver`.
 *
 * Note that the type does not care about the `isStatic` flag, but this guard does.
 * @param value any value
 */
export declare function isMethodMapDeclarationReflection(value: any): value is MethodMapDeclarationReflection;
/**
 * Type guard for a {@linkcode DeclarationReflectionWithReflectedType} a declaration reflection having a reflection type.
 *
 * I don't know what that means, exactly, but there it is.
 * @param value any value
 */
export declare function isReflectionWithReflectedType(value: any): value is DeclarationReflectionWithReflectedType;
export declare function isHTTPMethodDeclarationReflection(value: any): value is HTTPMethodDeclarationReflection;
/**
 * Type guard for an {@linkcode AllowedHttpMethod}
 *
 * @param value any value
 */
export declare function isAllowedHTTPMethod(value: any): value is AllowedHttpMethod;
/**
 * Type guard for a {@linkcode CommandPropDeclarationReflection} corresponding to the `command` property of a {@linkcode @appium/types#MethodDef} object contained within a {@linkcode @appium/types#MethodMap}.
 * @param value any value
 */
export declare function isCommandPropDeclarationReflection(value: any): value is CommandPropDeclarationReflection;
/**
 * Type guard for a {@linkcode ExecMethodData} derived from a {@linkcode @appium/types#ExecuteMethodMap} object.
 * @param value any value
 */
export declare function isExecMethodData(value: any): value is ExecMethodData;
/**
 * Type guard for a {@linkcode MethodDefParamsPropDeclarationReflection} corresponding to the `params` prop of a `MethodDef`
 * @param value any value
 */
export declare function isMethodDefParamsPropDeclarationReflection(value: any): value is MethodDefParamsPropDeclarationReflection;
/**
 * Type guard for a {@linkcode ExecMethodDefParamsPropDeclarationReflection} corresponding to the `payloadParams` prop of an `ExecuteMethodDef`.
 * @param value any value
 */
export declare function isExecMethodDefParamsPropDeclarationReflection(value: any): value is ExecMethodDefParamsPropDeclarationReflection;
/**
 * Type guard for a {@linkcode InterfaceDeclarationReflection} corresponding to a TS interface.
 * @param value any value
 */
export declare function isInterfaceDeclarationReflection(value: any): value is InterfaceDeclarationReflection;
/**
 * Type guard for a {@linkcode ExternalDriverDeclarationReflection} which is the `ExternalDriver`
 * interface defined in `@appium/types`.
 * @param value any value
 */
export declare function isExternalDriverDeclarationReflection(value: any): value is ExternalDriverDeclarationReflection;
/**
 * Type guard for an {@linkcode CommandMethodDeclarationReflection}, which is _potentially_ a method
 * for a command.  Not all async methods in driver classes are mapped to commands, of course!
 *
 * A command method cannot be static, but it can be an actual (async) function or a reference to an
 * (async) function; just depends how the code is written.  Either way, this asserts there's a
 * call signature returning a `Promise`.
 * @param value
 */
export declare function isCommandMethodDeclarationReflection(value: any): value is CommandMethodDeclarationReflection;
/**
 * Type guard for a {@linkcode ClassDeclarationReflection} which is just a {@linkcode DeclarationReflection}
 * with a `kind` of {@linkcode ReflectionKind.Class}.
 * @param value any value
 */
export declare function isClassDeclarationReflection(value: any): value is ClassDeclarationReflection;
/**
 * Type guard for a {@linkcode CallSignatureReflection} which is just a
 * {@linkcode SignatureReflection} with kind {@linkcode ReflectionKind.CallSignature}.
 * @param value any value
 */
export declare function isCallSignatureReflection(value: any): value is CallSignatureReflection;
/**
 * Type guard for a {@linkcode CallSignatureReflectionWithArity}, which is a
 * {@linkcode CallSignatureReflection} with an arity greater than zero.
 * @param value any value
 */
export declare function isCallSignatureReflectionWithArity(value: any): value is CallSignatureReflectionWithArity;
/**
 * Guard for {@linkcode ConstructorDeclarationReflection}
 * @param value any
 */
export declare function isConstructorDeclarationReflection(value: any): value is ConstructorDeclarationReflection;
/**
 * Guard for the constructor of a class extending `BasePlugin`
 * @param value
 */
export declare function isBasePluginConstructorDeclarationReflection(value: any): value is BasePluginConstructorDeclarationReflection;
/**
 * Guard for {@linkcode ParameterReflection}
 * @param value any
 */
export declare function isParameterReflection(value: any): value is ParameterReflection;
//# sourceMappingURL=guards.d.ts.map