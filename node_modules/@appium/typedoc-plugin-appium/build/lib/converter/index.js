"use strict";
/**
 * Converts code parsed by TypeDoc into a data structure describing the commands and execute methods, which will later be used to create new {@linkcode typedoc#DeclarationReflection} instances in the TypeDoc context.
 *
 * The logic in this module is highly dependent on Appium's extension API, and is further dependent on specific usages of TS types.  Anything that will be parsed successfully by this module must use a `const` type alias in TS parlance.  For example:
 *
 * ```ts
 * const METHOD_MAP = {
 *   '/status': {
 *     GET: {command: 'getStatus'}
 *   },
 *   // ...
 * } as const; // <-- required
 * ```
 * @module
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.convertCommands = void 0;
const model_1 = require("../model");
const builtin_external_driver_1 = require("./builtin-external-driver");
const builtin_method_map_1 = require("./builtin-method-map");
const external_1 = require("./external");
/**
 * Converts declarations into information about the commands found within
 * @param ctx - Current TypeDoc context
 * @param parentLog - Logger
 * @returns All commands found in the project
 */
function convertCommands(ctx, parentLog) {
    const log = parentLog.createChildLogger('converter');
    const bedConverter = new builtin_external_driver_1.BuiltinExternalDriverConverter(ctx, log);
    const builtinMethods = bedConverter.convert();
    const bmmConverter = new builtin_method_map_1.BuiltinMethodMapConverter(ctx, log, builtinMethods);
    const builtinCommands = bmmConverter.convert();
    const externalConverter = new external_1.ExternalConverter(ctx, log, builtinMethods, builtinCommands.moduleCmds);
    const externalCommands = externalConverter.convert();
    const allCommands = [...builtinCommands.toProjectCommands(), ...externalCommands];
    const projectCmds = new model_1.ProjectCommands(allCommands);
    if (projectCmds.isEmpty) {
        return;
    }
    return projectCmds;
}
exports.convertCommands = convertCommands;
__exportStar(require("../model/builtin-commands"), exports);
__exportStar(require("./base-converter"), exports);
__exportStar(require("./builder"), exports);
__exportStar(require("./builtin-external-driver"), exports);
__exportStar(require("./builtin-method-map"), exports);
__exportStar(require("./comment"), exports);
__exportStar(require("./exec-method-map"), exports);
__exportStar(require("./external"), exports);
__exportStar(require("./method-map"), exports);
__exportStar(require("./overrides"), exports);
__exportStar(require("./types"), exports);
__exportStar(require("./utils"), exports);
//# sourceMappingURL=index.js.map