"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BuiltinMethodMapConverter = exports.NAME_BUILTIN_COMMAND_MODULE = exports.NAME_BASE_DRIVER_CLASS = exports.NAME_METHOD_MAP = void 0;
const guards_1 = require("../guards");
const builtin_commands_1 = require("../model/builtin-commands");
const base_converter_1 = require("./base-converter");
const method_map_1 = require("./method-map");
const utils_1 = require("./utils");
/**
 * Name of the builtin method map in `@appium/base-driver`
 */
exports.NAME_METHOD_MAP = 'METHOD_MAP';
exports.NAME_BASE_DRIVER_CLASS = 'BaseDriver';
/**
 * Name of the module which contains the builtin method map
 */
exports.NAME_BUILTIN_COMMAND_MODULE = '@appium/base-driver';
class BuiltinMethodMapConverter extends base_converter_1.BaseConverter {
    /**
     * Creates a child logger for this instance
     * @param ctx Typedoc Context
     * @param log Logger
     */
    constructor(ctx, log, knownBuiltinMethods) {
        super(ctx, log.createChildLogger(exports.NAME_BUILTIN_COMMAND_MODULE));
        this.knownBuiltinMethods = knownBuiltinMethods;
    }
    /**
     * Converts `@appium/base-driver` into a `RouteMap`, if it can.
     *
     * @returns Object containing a declaration reflection of `@appium/base-driver` and its associated
     * route map (if found).
     */
    convert() {
        const { project } = this.ctx;
        const baseDriverModuleRefl = (0, utils_1.findParentReflectionByName)(project, exports.NAME_BUILTIN_COMMAND_MODULE);
        if (!(0, guards_1.isBaseDriverDeclarationReflection)(baseDriverModuleRefl)) {
            this.log.error('Could not find %s', exports.NAME_BUILTIN_COMMAND_MODULE);
            return new builtin_commands_1.BuiltinCommands();
        }
        this.log.verbose('Converting builtin method map');
        // we need base driver class to find methods implemented in it
        const baseDriverClassRefl = (0, utils_1.findChildByNameAndGuard)(baseDriverModuleRefl, exports.NAME_BASE_DRIVER_CLASS, guards_1.isClassDeclarationReflection);
        if (!baseDriverClassRefl) {
            this.log.error('Could not find module %s', exports.NAME_BUILTIN_COMMAND_MODULE);
            return new builtin_commands_1.BuiltinCommands();
        }
        const methodMap = baseDriverModuleRefl.getChildByName(exports.NAME_METHOD_MAP);
        if (!(0, guards_1.isMethodMapDeclarationReflection)(methodMap)) {
            this.log.error('Could not find %s in %s', exports.NAME_METHOD_MAP, exports.NAME_BUILTIN_COMMAND_MODULE);
            return new builtin_commands_1.BuiltinCommands();
        }
        const knownClassMethods = (0, utils_1.findCommandMethodsInReflection)(baseDriverClassRefl);
        const baseDriverRoutes = (0, method_map_1.convertMethodMap)({
            ctx: this.ctx,
            log: this.log,
            methodMapRefl: methodMap,
            parentRefl: baseDriverModuleRefl,
            knownClassMethods,
            knownBuiltinMethods: this.knownBuiltinMethods,
        });
        if (!baseDriverRoutes.size) {
            this.log.error('Could not find any commands in %s', exports.NAME_BUILTIN_COMMAND_MODULE);
            return new builtin_commands_1.BuiltinCommands();
        }
        return new builtin_commands_1.BuiltinCommands(baseDriverRoutes, baseDriverModuleRefl);
    }
}
exports.BuiltinMethodMapConverter = BuiltinMethodMapConverter;
//# sourceMappingURL=builtin-method-map.js.map