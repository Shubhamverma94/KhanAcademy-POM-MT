"use strict";
/**
 * Utils used across entire package
 * @module
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.findCallSignature = void 0;
const lodash_1 = __importDefault(require("lodash"));
const guards_1 = require("./guards");
/**
 * Loops through signatures of the command's method declaration and returns the first that is a
 * `CallSignatureReflection` (if any).  This is what we think of when we think "function signature"
 * This also works on DeclarationReflections that have a reflected type; in other words, some value that is the type of a function, but is not a function itself (such as a property assigned to a function).
 */
exports.findCallSignature = lodash_1.default.memoize((refl) => refl?.getAllSignatures()?.find(guards_1.isCallSignatureReflection) ??
    ((0, guards_1.isReflectionWithReflectedType)(refl)
        ? refl.type.declaration.getAllSignatures()?.find(guards_1.isCallSignatureReflection)
        : undefined));
//# sourceMappingURL=utils.js.map