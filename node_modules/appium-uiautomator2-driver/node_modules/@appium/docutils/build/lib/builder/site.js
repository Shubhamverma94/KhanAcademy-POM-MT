"use strict";
/**
 * Runs `mkdocs`, pulling in reference markdown from TypeDoc and any other documentation from the
 * `docs_dir` directory (as configured in `mkdocs.yml`).
 *
 * @module
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildSite = void 0;
const node_path_1 = __importDefault(require("node:path"));
const teen_process_1 = require("teen_process");
const constants_1 = require("../constants");
const error_1 = require("../error");
const fs_1 = require("../fs");
const logger_1 = require("../logger");
const util_1 = require("../util");
const log = (0, logger_1.getLogger)('mkdocs');
/**
 * Runs `mkdocs serve`
 * @param args Extra args to `mkdocs build`
 * @param opts Extra options for `teen_process.Subprocess.start`
 * @param mkDocsPath Path to `mkdocs` executable
 */
async function doServe(args = [], opts = {}, mkDocsPath) {
    mkDocsPath = mkDocsPath ?? (await (0, fs_1.whichMkDocs)());
    const finalArgs = ['serve', ...args];
    log.debug('Launching %s with args: %s', mkDocsPath, finalArgs);
    return (0, util_1.spawnBackgroundProcess)(mkDocsPath, finalArgs, opts);
}
/**
 * Runs `mkdocs build`
 * @param args Extra args to `mkdocs build`
 * @param opts Extra options to `teen_process.exec`
 * @param mkDocsPath Path to `mkdocs` executable
 */
async function doBuild(args = [], opts = {}, mkDocsPath) {
    mkDocsPath = mkDocsPath ?? (await (0, fs_1.whichMkDocs)());
    const finalArgs = ['build', ...args];
    log.debug('Launching %s with args: %O', mkDocsPath, finalArgs);
    return await (0, teen_process_1.exec)(mkDocsPath, finalArgs, opts);
}
/**
 * Runs `mkdocs build` or `mkdocs serve`
 * @param opts
 */
async function buildSite({ mkdocsYml: mkDocsYmlPath, siteDir, theme = constants_1.NAME_THEME, cwd = process.cwd(), serve = false, serveOpts, execOpts, } = {}) {
    const stop = (0, util_1.stopwatch)('build-mkdocs');
    mkDocsYmlPath = mkDocsYmlPath
        ? node_path_1.default.resolve(process.cwd(), mkDocsYmlPath)
        : await (0, fs_1.findMkDocsYml)(cwd);
    if (!mkDocsYmlPath) {
        throw new error_1.DocutilsError(`Could not find ${constants_1.NAME_MKDOCS_YML} from ${cwd}; run "${constants_1.NAME_BIN} init" to create it`);
    }
    const mkdocsArgs = ['-f', mkDocsYmlPath, '-t', theme];
    if (siteDir) {
        mkdocsArgs.push('-d', siteDir);
    }
    if (serve) {
        // unsure about how SIGHUP is handled here
        await doServe(mkdocsArgs, serveOpts);
    }
    else {
        log.info('Building site...');
        await doBuild(mkdocsArgs, execOpts);
        let relSiteDir;
        if (siteDir) {
            relSiteDir = (0, util_1.relative)(cwd, siteDir);
        }
        else {
            ({ site_dir: siteDir } = await (0, fs_1.readMkDocsYml)(mkDocsYmlPath));
            if (siteDir) {
                log.debug('Found site_dir %s', siteDir);
                relSiteDir = (0, util_1.relative)(node_path_1.default.dirname(mkDocsYmlPath), siteDir);
            }
            else {
                log.warn('No site_dir specified in args or %s; using default site_dir: %s', constants_1.NAME_MKDOCS_YML, constants_1.DEFAULT_SITE_DIR);
                relSiteDir = (0, util_1.relative)(cwd, constants_1.DEFAULT_SITE_DIR);
            }
        }
        log.success('Finished building site into %s (%dms)', relSiteDir, stop());
    }
}
exports.buildSite = buildSite;
//# sourceMappingURL=site.js.map