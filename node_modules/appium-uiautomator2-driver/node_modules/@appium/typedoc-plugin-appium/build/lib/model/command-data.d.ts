import { Comment, Context, DeclarationReflection, ParameterReflection, SignatureReflection } from 'typedoc';
import { CommandMethodDeclarationReflection, CommentSource, Example, KnownMethods } from '../converter';
import { AppiumPluginLogger } from '../logger';
import { AllowedHttpMethod, Command, Route } from './types';
/**
 * Abstract representation of metadata for some sort of Appium command
 */
export declare abstract class BaseCommandData {
    readonly opts: BaseCommandDataOpts;
    /**
     * Loggher
     */
    protected readonly log: AppiumPluginLogger;
    /**
     * The method name of the command handler.
     */
    readonly command: string;
    /**
     * The comment to display for the command, if any exists
     */
    readonly comment?: Comment;
    /**
     * Code to describe how and where {@linkcode comment} came from.
     *
     * For debugging purposes mainly
     */
    readonly commentSource?: CommentSource;
    /**
     * Language-specific examples for the command, if any
     */
    readonly examples?: Example[];
    /**
     * If `true`, this command is from a Plugin (not a Driver)
     */
    readonly isPluginCommand: boolean;
    /**
     * Map of known builtin methods
     */
    readonly knownBuiltinMethods?: KnownMethods;
    /**
     * Actual method reflection.
     */
    readonly methodRefl: CommandMethodDeclarationReflection;
    /**
     * List of optional parameter names derived from a method map
     */
    readonly optionalParams?: string[];
    /**
     * Parameter reflections for this command's method declaration, to eventually be displayed in rendered docs
     *
     * These are _not_ the same objects as in the `parameters` property of a the call signature
     * reflection in `methodRefl`; the comments therein have been aggregated and the parameters have
     * been renamed and possibly truncated.
     */
    readonly parameters?: ParameterReflection[];
    /**
     * The thing which the method is a member of for documentation purposes
     */
    readonly parentRefl?: DeclarationReflection;
    /**
     * List of required parameter names derived from a method map
     */
    readonly requiredParams?: string[];
    /**
     * Signature reflection for this command's method declaration, to eventually be displayed in
     * rendered docs
     *
     * `methodRefl` is a {@linkcode CommandMethodDeclarationReflection}, so it returns a `Promise<T>`, by
     * definition.  This signature reflection is modified so that it returns `T` instead, since
     * `Promise`s don't make much sense in the rendered documentaion.
     *
     * The default TypeDoc output uses the original `SignatureReflection`, so you _will_ see
     * `Promise<T>` there.
     */
    readonly signature?: SignatureReflection;
    constructor(log: AppiumPluginLogger, command: Command, methodRefl: CommandMethodDeclarationReflection, opts?: BaseCommandDataOpts);
    /**
     * Returns `true` if the method or execute map defined parameters for this command
     */
    get hasCommandParams(): boolean;
    /**
     * Returns a list of `ParameterReflection` objects in the command's method declaration;
     * rewrites them to prefer the method map parameter list (and the param names)
     */
    private rewriteParameters;
    /**
     *
     * Rewrites a method's return value for documentation.
     *
     * Given a command having a method declaration, creates a clone of its call signature wherein the
     * return type is unwrapped from `Promise`.  In other words, if a method returns `Promise<T>`,
     * this changes the return type in the signature to `T`.
     *
     * Note that the return type of a command's method declaration should always be a `ReferenceType` having
     * name `Promise`.
     */
    private rewriteSignature;
}
/**
 * Options for {@linkcode CommandData} and {@linkcode ExecMethodData} constructors
 */
export interface BaseCommandDataOpts {
    /**
     * The comment to display for the command, if any exists
     */
    comment?: Comment;
    /**
     * Name of the reference which the comment is derived from.
     *
     * For debugging purposes mainly
     */
    commentSource?: CommentSource;
    /**
     * If `true`, `refl` represents a `PluginCommand`, wherein we will ignore
     * the first two parameters altogether.
     */
    isPluginCommand?: boolean;
    /**
     * Known methods in the project
     */
    knownBuiltinMethods?: KnownMethods;
    /**
     * List of optional parameter names derived from a method map
     */
    optionalParams?: string[];
    /**
     * The thing which the method is a member of for documentation purposes
     */
    parentRefl?: DeclarationReflection;
    /**
     * List of required parameter names derived from a method map
     */
    requiredParams?: string[];
}
/**
 * Represents a generic WD or Appium-specific endpoint
 */
export declare class CommandData extends BaseCommandData {
    /**
     * The HTTP method of the route
     */
    readonly httpMethod: AllowedHttpMethod;
    /**
     * The route of the command
     */
    readonly route: Route;
    /**
     * Use {@linkcode CommandData.create} instead
     */
    private constructor();
    /**
     * Creates a **shallow** clone of this instance.
     *
     * @param commandData Instance to clone
     * @param ctx Context
     * @param overrides Override any properties of the instance here (including {@linkcode CommandData.opts})
     * @returns Cloned instance
     */
    static clone(commandData: CommandData, ctx: Context, overrides?: Partial<CommandData>): CommandData;
    /**
     * Creates a new instance of {@linkcode CommandData} and registers any newly-created reflections
     * with TypeDoc.
     * @param ctx Context
     * @param log Logger
     * @param command Command name
     * @param methodRefl Command method reflection
     * @param httpMethod HTTP method of route
     * @param route Route path
     * @param opts Options
     * @returns
     */
    static create(ctx: Context, log: AppiumPluginLogger, command: Command, methodRefl: CommandMethodDeclarationReflection, httpMethod: AllowedHttpMethod, route: Route, opts?: BaseCommandDataOpts): CommandData;
}
/**
 * Represents an "execute command" ("execute method")
 *
 * Each will have a unique `script` property which is provided as the script to run via the
 * `execute` WD endpoint.
 *
 * All of these share the same `execute` route, so it is omitted from this interface.
 */
export declare class ExecMethodData extends BaseCommandData {
    readonly script: string;
    readonly opts: BaseCommandDataOpts;
    /**
     * Use {@linkcode ExecMethodData.create} instead
     * @param log Logger
     * @param command Command name
     * @param methodRefl method reflection
     * @param script Script name (not the same as command name); this is what is passed to the `execute` endpoint
     */
    private constructor();
    /**
     * Creates a **shallow** clone of this instance.
     *
     * @param execMethodData Instance to clone
     * @param ctx Context
     * @param overrides Override any properties of the instance here (including {@linkcode ExecMethodData.opts})
     * @returns Cloned instance
     */
    static clone(execMethodData: ExecMethodData, ctx: Context, overrides?: Partial<ExecMethodData>): ExecMethodData;
    /**
     * Creates a new instance of {@linkcode CommandData} and registers any newly-created reflections
     * with TypeDoc.
     * @param ctx Context
     * @param log Logger
     * @param command Command name
     * @param script Script name
     * @param route Route path
     * @param opts Options
     */
    static create(ctx: Context, log: AppiumPluginLogger, command: Command, methodRefl: CommandMethodDeclarationReflection, script: string, opts?: BaseCommandDataOpts): ExecMethodData;
}
//# sourceMappingURL=command-data.d.ts.map