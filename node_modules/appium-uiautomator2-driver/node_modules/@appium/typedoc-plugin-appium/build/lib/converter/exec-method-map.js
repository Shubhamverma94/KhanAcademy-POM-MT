"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.convertExecuteMethodMap = void 0;
const lodash_1 = __importDefault(require("lodash"));
const typedoc_1 = require("typedoc");
const guards_1 = require("../guards");
const model_1 = require("../model");
const comment_1 = require("./comment");
const utils_1 = require("./utils");
/**
 * Gathers info about an `executeMethodMap` prop in a driver
 * @param opts Options (mostly non-optional)
 * @returns List of "execute commands", if any
 */
function convertExecuteMethodMap({ ctx, log, parentRefl, execMethodMapRefl, knownMethods, strict = false, isPluginCommand = false, }) {
    const commandRefs = new Set();
    if (!execMethodMapRefl) {
        // no execute commands in this class
        return commandRefs;
    }
    const newMethodProps = (0, utils_1.filterChildrenByKind)(execMethodMapRefl, typedoc_1.ReflectionKind.Property);
    for (const newMethodProp of newMethodProps) {
        const { comment, originalName: script } = newMethodProp;
        const commandProp = (0, utils_1.findChildByGuard)(newMethodProp, guards_1.isCommandPropDeclarationReflection);
        if (!commandProp) {
            // this is a bug in the driver implementation
            log.warn('Execute method map in %s has no "command" property for %s', parentRefl.name, script);
            continue;
        }
        if (!lodash_1.default.isString(commandProp.type.value) || lodash_1.default.isEmpty(commandProp.type.value)) {
            // this is a bug in the driver implementation
            log.warn('Execute method map in %s has an empty or invalid "command" property for %s', parentRefl.name, script);
            continue;
        }
        const command = String(commandProp.type.value);
        const paramsProp = (0, utils_1.findChildByGuard)(newMethodProp, guards_1.isExecMethodDefParamsPropDeclarationReflection);
        const requiredParams = (0, utils_1.convertRequiredCommandParams)(paramsProp);
        const optionalParams = (0, utils_1.convertOptionalCommandParams)(paramsProp);
        const methodRefl = knownMethods.get(command);
        if (!methodRefl) {
            if (strict) {
                log.error('No method found for command "%s" from script "%s"', command, script);
            }
            continue;
        }
        const commentData = (0, comment_1.deriveComment)({ refl: methodRefl, comment, knownMethods });
        const execMethodData = model_1.ExecMethodData.create(ctx, log, command, methodRefl, script, {
            requiredParams,
            optionalParams,
            comment: commentData?.comment,
            commentSource: commentData?.commentSource,
            isPluginCommand,
        });
        commandRefs.add(execMethodData);
        log.verbose('Added POST route %s for command "%s" from script "%s"', model_1.NAME_EXECUTE_ROUTE, command, script);
    }
    return commandRefs;
}
exports.convertExecuteMethodMap = convertExecuteMethodMap;
//# sourceMappingURL=exec-method-map.js.map