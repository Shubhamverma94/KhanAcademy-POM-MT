/**
 * Utilities for the various converters.
 * @module
 */
import { ParameterReflection, ProjectReflection, Reflection, SignatureReflection, SomeType, TypeParameterReflection } from 'typedoc';
import { ParentReflection } from '../model';
import { CallSignatureReflection, ClassDeclarationReflection, CommandMethodDeclarationReflection, InterfaceDeclarationReflection, KnownMethods } from './types';
export declare function findParentReflectionByName(project: ProjectReflection, name: string): ParentReflection | undefined;
/**
 * Finds _all_ async command methods in a class or interface
 * @param refl Class reflection
 * @returns Map of method names to method reflections
 */
export declare function findCommandMethodsInReflection(refl: ClassDeclarationReflection | InterfaceDeclarationReflection): KnownMethods;
/**
 * Clones a `ParameterReflection`.
 *
 * @privateRemarks I think.
 * @param pRefl A `ParameterReflection`
 * @param param Desired name of parameter
 * @param parent Custom signature reflection
 * @param knownMethods Builtin methods for aggregating comments
 * @param optional If the parameter is considered "optional"
 * @returns A new `ParameterReflection` based on the first
 */
export declare function cloneParameterReflection(pRefl: ParameterReflection, param: string, parent: SignatureReflection, knownMethods?: KnownMethods, optional?: boolean): ParameterReflection;
/**
 * Clones a type parameter reflection
 * @param tPRefl Type parameter reflection
 * @param parentRefl Parent
 * @returns A clone of the original type parameter reflection
 */
export declare function cloneTypeParameterReflection(tPRefl: TypeParameterReflection, parentRefl: Reflection): TypeParameterReflection;
/**
 * This loops over a list of command parameter names as defined in the method/execute map and attempts
 * to create a new `ParameterReflection` for each, based on the given data.
 *
 * Because the command param names are essentially properties of a JSON object and the
 * `ParameterReflection` instances represent the arguments of a method, we must match them by
 * index. In JS, optional arguments cannot become before required arguments in a function
 * signature, so we can do those first. If there are _more_ method arguments than command param
 * names, we toss them out, because they may not be part of the public API.
 * @param sig Signature reflection
 * @param opts Options
 * @returns List of refls with names matching `commandParams`, throwing out any extra refls
 */
export declare function createNewParamRefls(sig: SignatureReflection, opts?: CreateNewParamReflsOpts): ParameterReflection[];
/**
 * Clones a `CallSignatureReflection` with a new parent and type.
 *
 * This does a "deep" clone inasmuch as it clones any associated `ParameterReflection` and
 * `TypeParameterReflection` instances.
 *
 * @privateRemarks I'm not sure this is sufficient.
 * @param sig A `CallSignatureReflection` to clone
 * @param parent The desired parent of the new `CallSignatureReflection`
 * @param type The desired type of the new `CallSignatureReflection`; if not provided, the original type
 * will be used
 * @returns A clone of `sig` with the given parent and type
 */
export declare function cloneCallSignatureReflection(sig: CallSignatureReflection, parent: CommandMethodDeclarationReflection, type?: SomeType): SignatureReflection & Partial<CallSignatureReflection> & {
    parameters: ParameterReflection[];
    typeParameters: TypeParameterReflection[];
    type: SomeType | undefined;
};
/**
 * Options for {@linkcode createNewParamRefls}
 */
export interface CreateNewParamReflsOpts {
    /**
     * Map of known methods
     */
    builtinMethods?: KnownMethods;
    /**
     * List of parameter names from method def
     */
    commandParams?: string[];
    /**
     * If the parameter is marked as optional in the method def
     */
    isOptional?: boolean;
    /**
     * If the class containing the method is a Plugin.
     *
     * This is important because the `PluginCommand` type has a different signature than the
     * `DriverCommand` type; the former always has two specific arguments heading its parameter list,
     * and we do not need to include in the generated docs.
     */
    isPluginCommand?: boolean;
}
//# sourceMappingURL=utils.d.ts.map