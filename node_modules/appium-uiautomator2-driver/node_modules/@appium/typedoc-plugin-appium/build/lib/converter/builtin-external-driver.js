"use strict";
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _BuiltinExternalDriverConverter_instances, _BuiltinExternalDriverConverter_convertMethodDeclarations;
Object.defineProperty(exports, "__esModule", { value: true });
exports.BuiltinExternalDriverConverter = exports.NAME_EXTERNAL_DRIVER = exports.NAME_TYPES_MODULE = void 0;
const pluralize_1 = __importDefault(require("pluralize"));
const guards_1 = require("../guards");
const base_converter_1 = require("./base-converter");
const utils_1 = require("./utils");
/**
 * Name of the module containing `ExternalDriver`
 */
exports.NAME_TYPES_MODULE = '@appium/types';
/**
 * Name of `ExternalDriver` interface
 */
exports.NAME_EXTERNAL_DRIVER = 'ExternalDriver';
/**
 * Converts `@appium/types` into a `KnownMethods`, if it can.
 */
class BuiltinExternalDriverConverter extends base_converter_1.BaseConverter {
    /**
     * Creates a child logger for this instance
     * @param ctx Typedoc Context
     * @param log Logger
     */
    constructor(ctx, log) {
        super(ctx, log.createChildLogger(exports.NAME_TYPES_MODULE));
        this.ctx = ctx;
        _BuiltinExternalDriverConverter_instances.add(this);
    }
    convert() {
        const { project } = this.ctx;
        const typesModule = (0, utils_1.findParentReflectionByName)(project, exports.NAME_TYPES_MODULE);
        if (!(0, guards_1.isAppiumTypesReflection)(typesModule)) {
            this.log.error('Could not find %s', exports.NAME_TYPES_MODULE);
            return new Map();
        }
        this.log.verbose('Found %s; converting', exports.NAME_EXTERNAL_DRIVER);
        return __classPrivateFieldGet(this, _BuiltinExternalDriverConverter_instances, "m", _BuiltinExternalDriverConverter_convertMethodDeclarations).call(this, typesModule);
    }
}
exports.BuiltinExternalDriverConverter = BuiltinExternalDriverConverter;
_BuiltinExternalDriverConverter_instances = new WeakSet(), _BuiltinExternalDriverConverter_convertMethodDeclarations = function _BuiltinExternalDriverConverter_convertMethodDeclarations(refl) {
    const externalDriverRefl = refl.getChildByName(exports.NAME_EXTERNAL_DRIVER);
    let methods = new Map();
    if (!(0, guards_1.isExternalDriverDeclarationReflection)(externalDriverRefl)) {
        this.log.error('Could not find %s', exports.NAME_EXTERNAL_DRIVER);
        return methods;
    }
    methods = (0, utils_1.findCommandMethodsInReflection)(externalDriverRefl);
    if (!methods.size) {
        this.log.error('(%s) No methods found! This is a bug.', exports.NAME_EXTERNAL_DRIVER);
        return methods;
    }
    this.log.verbose('(%s) Done; found %s', exports.NAME_EXTERNAL_DRIVER, (0, pluralize_1.default)('builtin command method', methods.size, true));
    return methods;
};
//# sourceMappingURL=builtin-external-driver.js.map