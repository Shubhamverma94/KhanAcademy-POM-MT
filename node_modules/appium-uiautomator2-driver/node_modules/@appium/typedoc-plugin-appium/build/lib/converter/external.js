"use strict";
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _ExternalConverter_instances, _ExternalConverter_convertModuleClasses, _ExternalConverter_findAndConvertExecMethodMap, _ExternalConverter_findAndConvertNewMethodMap;
Object.defineProperty(exports, "__esModule", { value: true });
exports.ExternalConverter = exports.NAME_BASE_PLUGIN = exports.NAME_PAYLOAD_PARAMS = exports.NAME_COMMAND = exports.NAME_PARAMS = exports.NAME_OPTIONAL = exports.NAME_REQUIRED = exports.NAME_EXECUTE_METHOD_MAP = exports.NAME_NEW_METHOD_MAP = void 0;
const lodash_1 = __importDefault(require("lodash"));
const pluralize_1 = __importDefault(require("pluralize"));
const typedoc_1 = require("typedoc");
const guards_1 = require("../guards");
const model_1 = require("../model");
const base_converter_1 = require("./base-converter");
const exec_method_map_1 = require("./exec-method-map");
const method_map_1 = require("./method-map");
const overrides_1 = require("./overrides");
const utils_1 = require("./utils");
/**
 * Name of the static `newMethodMap` property in a Driver or Plugin
 */
exports.NAME_NEW_METHOD_MAP = 'newMethodMap';
/**
 * Name of the static `executeMethodMap` property in a Driver
 */
exports.NAME_EXECUTE_METHOD_MAP = 'executeMethodMap';
/**
 * Name of the field in a method map's parameters prop which contains required parameters
 */
exports.NAME_REQUIRED = 'required';
/**
 * Name of the field in a method map's parameters prop which contains optional parameters
 */
exports.NAME_OPTIONAL = 'optional';
/**
 * Name of the field in an _execute_ method map which contains parameters
 */
exports.NAME_PARAMS = 'params';
/**
 * Name of the command in a method map
 */
exports.NAME_COMMAND = 'command';
/**
 * Name of the field in a _regular_ method map which contains parameters
 */
exports.NAME_PAYLOAD_PARAMS = 'payloadParams';
exports.NAME_BASE_PLUGIN = 'BasePlugin';
/**
 * Converts declarations to information about Appium commands
 */
class ExternalConverter extends base_converter_1.BaseConverter {
    /**
     * Creates a child logger for this instance
     * @param ctx Typedoc Context
     * @param log Logger
     */
    constructor(ctx, log, builtinMethods, builtinCommands) {
        super(ctx, log.createChildLogger('extension'), builtinCommands);
        this.builtinMethods = builtinMethods;
        this.builtinCommands = builtinCommands;
        _ExternalConverter_instances.add(this);
    }
    /**
     * Converts declarations into command information
     *
     * @returns Command info for entire project
     */
    convert() {
        const ctx = this.ctx;
        const { project } = ctx;
        const projectCommands = new model_1.ProjectCommands();
        // convert all modules (or just project if no modules)
        const modules = project.getChildrenByKind(typedoc_1.ReflectionKind.Module);
        if (modules.length) {
            for (const mod of modules) {
                const log = this.log.createChildLogger(mod.name);
                log.verbose('(%s) Begin conversion', mod.name);
                const cmdInfo = __classPrivateFieldGet(this, _ExternalConverter_instances, "m", _ExternalConverter_convertModuleClasses).call(this, mod, log);
                projectCommands.set(mod.name, cmdInfo);
                log.verbose('(%s) End conversion', mod.name);
            }
        }
        else {
            const log = this.log.createChildLogger(project.name);
            log.verbose('(%s) Begin conversion', project.name);
            const cmdInfo = __classPrivateFieldGet(this, _ExternalConverter_instances, "m", _ExternalConverter_convertModuleClasses).call(this, project, log);
            projectCommands.set(project.name, cmdInfo);
            log.verbose('(%s) End conversion', project.name);
        }
        if (projectCommands.size) {
            const routeSum = lodash_1.default.sumBy([...projectCommands], ([, info]) => info.routeMap.size);
            const execMethodSum = lodash_1.default.sumBy([...projectCommands], ([, info]) => info.execMethodDataSet.size);
            this.log.info('Found %s and %s in %s', (0, pluralize_1.default)('command', routeSum, true), (0, pluralize_1.default)('execute method', execMethodSum, true), (0, pluralize_1.default)('module', modules.length, true));
        }
        else {
            this.log.error('No commands nor execute methods found in entire project!');
        }
        return projectCommands;
    }
}
exports.ExternalConverter = ExternalConverter;
_ExternalConverter_instances = new WeakSet(), _ExternalConverter_convertModuleClasses = function _ExternalConverter_convertModuleClasses(parentRefl, log) {
    let routeMap = new Map();
    let execMethodData = new Set();
    const classReflections = (0, utils_1.filterChildrenByGuard)(parentRefl, guards_1.isClassDeclarationReflection);
    for (const classRefl of classReflections) {
        const isPlugin = (0, guards_1.isBasePluginConstructorDeclarationReflection)((0, utils_1.findChildByGuard)(classRefl, guards_1.isConstructorDeclarationReflection));
        const classMethods = (0, utils_1.findCommandMethodsInReflection)(classRefl);
        if (!classMethods.size) {
            // may or may not be expected
            log.verbose('(%s) No command methods found', classRefl.name);
            continue;
        }
        log.verbose('(%s) Analyzing %s', classRefl.name, (0, pluralize_1.default)('method', classMethods.size, true));
        const newRouteMap = __classPrivateFieldGet(this, _ExternalConverter_instances, "m", _ExternalConverter_findAndConvertNewMethodMap).call(this, classRefl, classMethods, log, isPlugin);
        routeMap = new Map([...routeMap, ...newRouteMap]);
        const newExecMethodData = __classPrivateFieldGet(this, _ExternalConverter_instances, "m", _ExternalConverter_findAndConvertExecMethodMap).call(this, classRefl, classMethods, log, isPlugin);
        execMethodData = new Set([...execMethodData, ...newExecMethodData]);
        const overriddenRouteMap = this.builtinCommands
            ? (0, overrides_1.convertOverrides)({
                ctx: this.ctx,
                log,
                parentRefl: classRefl,
                classMethods,
                builtinMethods: this.builtinMethods,
                newRouteMap,
                newExecMethodMap: execMethodData,
                builtinCommands: this.builtinCommands,
            })
            : new Map();
        routeMap = new Map([...routeMap, ...overriddenRouteMap]);
        log.verbose('(%s) Done; found %s and %s', classRefl.name, (0, pluralize_1.default)('total command', newRouteMap.size + overriddenRouteMap.size, true), (0, pluralize_1.default)('total execute method', newExecMethodData.size, true));
    }
    return new model_1.ModuleCommands(routeMap, execMethodData);
}, _ExternalConverter_findAndConvertExecMethodMap = function _ExternalConverter_findAndConvertExecMethodMap(parentRefl, methods, log, isPluginCommand) {
    const execMethodMapRefl = (0, utils_1.findChildByGuard)(parentRefl, guards_1.isExecMethodDefReflection);
    if (!execMethodMapRefl) {
        log.verbose('(%s) No execute method map found', parentRefl.name);
        return new Set();
    }
    return (0, exec_method_map_1.convertExecuteMethodMap)({
        ctx: this.ctx,
        log,
        parentRefl,
        execMethodMapRefl,
        knownMethods: methods,
        strict: true,
        isPluginCommand,
    });
}, _ExternalConverter_findAndConvertNewMethodMap = function _ExternalConverter_findAndConvertNewMethodMap(parentRefl, methods, log, isPluginCommand) {
    const newMethodMapRefl = (0, utils_1.findChildByNameAndGuard)(parentRefl, exports.NAME_NEW_METHOD_MAP, guards_1.isMethodMapDeclarationReflection);
    if (!newMethodMapRefl) {
        log.verbose('(%s) No new method map found', parentRefl.name);
        return new Map();
    }
    return (0, method_map_1.convertMethodMap)({
        ctx: this.ctx,
        log,
        methodMapRefl: newMethodMapRefl,
        parentRefl,
        knownClassMethods: methods,
        knownBuiltinMethods: this.builtinMethods,
        strict: true,
        isPluginCommand,
    });
};
//# sourceMappingURL=external.js.map