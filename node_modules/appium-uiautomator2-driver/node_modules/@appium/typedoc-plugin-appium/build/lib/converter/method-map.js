"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.convertMethodMap = void 0;
const lodash_1 = __importDefault(require("lodash"));
const typedoc_1 = require("typedoc");
const guards_1 = require("../guards");
const model_1 = require("../model");
const comment_1 = require("./comment");
const utils_1 = require("./utils");
/**
 * Extracts information about `MethodMap` objects
 * @param opts Options
 * @returns Lookup of routes to {@linkcode CommandSet} objects
 */
function convertMethodMap({ ctx, log, methodMapRefl, parentRefl, knownClassMethods, knownBuiltinMethods, strict = false, isPluginCommand = false, }) {
    const routes = new Map();
    const routeProps = (0, utils_1.filterChildrenByKind)(methodMapRefl, typedoc_1.ReflectionKind.Property);
    if (!routeProps.length) {
        if (methodMapRefl.overwrites?.name === 'BasePlugin') {
            log.warn('(%s) MethodMap; skipping');
        }
        return routes;
    }
    for (const routeProp of routeProps) {
        const { originalName: route } = routeProp;
        if (!(0, guards_1.isRoutePropDeclarationReflection)(routeProp)) {
            log.warn('Empty route: %s', route);
            continue;
        }
        const httpMethodProps = (0, utils_1.filterChildrenByGuard)(routeProp, guards_1.isHTTPMethodDeclarationReflection);
        if (!httpMethodProps.length) {
            log.warn('No HTTP methods found in route %s', route);
            continue;
        }
        for (const httpMethodProp of httpMethodProps) {
            const { comment: mapComment, name: httpMethod } = httpMethodProp;
            const commandProp = (0, utils_1.findChildByGuard)(httpMethodProp, guards_1.isCommandPropDeclarationReflection);
            // commandProp is optional.
            if (!commandProp) {
                continue;
            }
            if (!lodash_1.default.isString(commandProp.type.value) || lodash_1.default.isEmpty(commandProp.type.value)) {
                log.warn('Empty command name found in %s - %s', route, httpMethod);
                continue;
            }
            const command = String(commandProp.type.value);
            const method = knownClassMethods.get(command);
            if (!method) {
                if (strict) {
                    log.error('(%s) No method found for command "%s"; this may be a bug', parentRefl.name, command);
                }
                continue;
            }
            const commentData = (0, comment_1.deriveComment)({
                refl: method,
                comment: mapComment,
                knownMethods: knownBuiltinMethods,
            });
            const { comment, commentSource } = commentData ?? {};
            const payloadParamsProp = (0, utils_1.findChildByGuard)(httpMethodProp, guards_1.isMethodDefParamsPropDeclarationReflection);
            const requiredParams = (0, utils_1.convertRequiredCommandParams)(payloadParamsProp);
            const optionalParams = (0, utils_1.convertOptionalCommandParams)(payloadParamsProp);
            const commandSet = routes.get(route) ?? new Set();
            const commandData = model_1.CommandData.create(ctx, log, command, method, httpMethod, route, {
                requiredParams,
                optionalParams,
                comment,
                commentSource,
                parentRefl,
                isPluginCommand,
                knownBuiltinMethods,
            });
            commandSet.add(commandData);
            log.verbose('(%s) Registered route %s %s for command "%s"', parentRefl.name, httpMethod, route, command);
            routes.set(route, commandSet);
        }
    }
    return routes;
}
exports.convertMethodMap = convertMethodMap;
//# sourceMappingURL=method-map.js.map