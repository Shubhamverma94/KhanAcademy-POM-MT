"use strict";
/**
 * Adapted from `@knodes/typedoc-pluginutils`
 *
 * Portions Copyright (c) 2022 KnodesCommunity
 * Licensed MIT
 *
 * @module
 * @see https://github.com/KnodesCommunity/typedoc-plugins/blob/ed5e4e87f5d80abf6352e8de353ea376c4f7db6d/packages/pluginutils/src/plugin-logger.ts
 *
 */
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _AppiumPluginLogger_instances, _AppiumPluginLogger_logThroughParent, _AppiumPluginLogger_parent, _AppiumPluginLogger_formatMessage, _AppiumPluginLogger_log, _AppiumPluginLogger_logThrough;
Object.defineProperty(exports, "__esModule", { value: true });
exports.fallbackLogger = exports.AppiumPluginLogger = void 0;
const lodash_1 = __importDefault(require("lodash"));
const node_util_1 = require("node:util");
const typedoc_1 = require("typedoc");
const path_1 = __importDefault(require("path"));
// this is a hack to get around package export restrictions.
// since TypeDoc's ConsoleLogger is a private API, we will fall back to a vanilla `Logger`;
// I'm not entirely sure what it will do.
let ConsoleLogger;
try {
    // eslint-disable-next-line @typescript-eslint/no-var-requires
    ConsoleLogger = require(path_1.default.join(path_1.default.dirname(require.resolve('typedoc/package.json')), 'dist', 'lib', 'utils')).ConsoleLogger;
}
catch {
    ConsoleLogger = typedoc_1.Logger;
}
/**
 * Mapping of TypeDoc {@linkcode LogLevel}s to method names.
 */
const LogMethods = new Map([
    [typedoc_1.LogLevel.Error, 'error'],
    [typedoc_1.LogLevel.Warn, 'warn'],
    [typedoc_1.LogLevel.Info, 'info'],
    [typedoc_1.LogLevel.Verbose, 'verbose'],
]);
class AppiumPluginLogger extends typedoc_1.Logger {
    constructor(logger, ns, logThroughParent) {
        super();
        _AppiumPluginLogger_instances.add(this);
        /**
         * Function provided by `AppiumPluginLogger` parent loggers to log through them.
         */
        _AppiumPluginLogger_logThroughParent.set(this, void 0);
        /**
         * Parent logger
         */
        _AppiumPluginLogger_parent.set(this, void 0);
        __classPrivateFieldSet(this, _AppiumPluginLogger_parent, logger, "f");
        this.ns = ns;
        this.level = __classPrivateFieldGet(this, _AppiumPluginLogger_parent, "f").level;
        __classPrivateFieldSet(this, _AppiumPluginLogger_logThroughParent, logThroughParent, "f");
    }
    /**
     * Create a new {@link AppiumPluginLogger} for the given context.
     *
     * @param ns - New sub-namespace; will be appended to the current namespace.
     * @returns the new logger.
     */
    createChildLogger(ns) {
        return AppiumPluginLogger.createChildLogger(this, ns);
    }
    /**
     * Log the given error message.
     *
     * @param text  - The error that should be logged.
     */
    error(text, ...args) {
        __classPrivateFieldGet(this, _AppiumPluginLogger_instances, "m", _AppiumPluginLogger_log).call(this, typedoc_1.LogLevel.Error, text, ...args);
    }
    /**
     * Log the given info message.
     *
     * @param text  - The message that should be logged.
     */
    info(text, ...args) {
        __classPrivateFieldGet(this, _AppiumPluginLogger_instances, "m", _AppiumPluginLogger_log).call(this, typedoc_1.LogLevel.Info, text, ...args);
    }
    /**
     * Print a log message.
     *
     * Does _not_ support `printf`-style syntax for compatibility with {@linkcode Logger}.
     *
     * @param text  - The message itself.
     * @param level  - The urgency of the log message.
     */
    log(text, level) {
        __classPrivateFieldGet(this, _AppiumPluginLogger_instances, "m", _AppiumPluginLogger_log).call(this, level, text);
    }
    /**
     * Log the given verbose message.
     *
     * @param text - The message that should be logged.
     */
    verbose(text, ...args) {
        __classPrivateFieldGet(this, _AppiumPluginLogger_instances, "m", _AppiumPluginLogger_log).call(this, typedoc_1.LogLevel.Verbose, text, ...args);
    }
    /**
     * Log the given warning message.
     *
     * @param text - The warning that should be logged.
     */
    warn(text, ...args) {
        __classPrivateFieldGet(this, _AppiumPluginLogger_instances, "m", _AppiumPluginLogger_log).call(this, typedoc_1.LogLevel.Warn, text, ...args);
    }
}
exports.AppiumPluginLogger = AppiumPluginLogger;
_AppiumPluginLogger_logThroughParent = new WeakMap(), _AppiumPluginLogger_parent = new WeakMap(), _AppiumPluginLogger_instances = new WeakSet(), _AppiumPluginLogger_formatMessage = function _AppiumPluginLogger_formatMessage(ns, message, ...args) {
    return (0, node_util_1.format)(`[${ns}] ${message}`, ...args);
}, _AppiumPluginLogger_log = function _AppiumPluginLogger_log(level, text, ...args) {
    if (level < this.level) {
        return;
    }
    __classPrivateFieldGet(this, _AppiumPluginLogger_instances, "m", _AppiumPluginLogger_logThrough).call(this, level, this.ns, text, ...args);
}, _AppiumPluginLogger_logThrough = function _AppiumPluginLogger_logThrough(level, ns, message, ...args) {
    if (__classPrivateFieldGet(this, _AppiumPluginLogger_logThroughParent, "f")) {
        __classPrivateFieldGet(this, _AppiumPluginLogger_logThroughParent, "f").call(this, level, ns, message, ...args);
    }
    else {
        const parentMethod = LogMethods.get(level);
        __classPrivateFieldGet(this, _AppiumPluginLogger_parent, "f")[parentMethod](__classPrivateFieldGet(this, _AppiumPluginLogger_instances, "m", _AppiumPluginLogger_formatMessage).call(this, ns, message, ...args));
    }
};
/**
 * Creates or retrieves a child logger for the given namespace
 * @param parent Parent logger
 * @param ns Namespace
 * @returns Child logger
 */
AppiumPluginLogger.createChildLogger = lodash_1.default.memoize((parent, ns) => {
    const newLogger = new AppiumPluginLogger(__classPrivateFieldGet(parent, _AppiumPluginLogger_parent, "f"), `${parent.ns}:${ns}`, __classPrivateFieldGet(parent, _AppiumPluginLogger_instances, "m", _AppiumPluginLogger_logThrough).bind(parent));
    newLogger.level = parent.level;
    return newLogger;
}, (parent, ns) => `${parent.ns}:${ns}`);
/**
 * Fallback logger. **Do not use this unless you really mean it.**
 *
 * Prefer to pass a `Logger` or `AppiumPluginLogger` instance to the constructor of the class you
 * are using or the function you are calling.  If this makes the API too cumbersome, consider using this.
 */
exports.fallbackLogger = new AppiumPluginLogger(new ConsoleLogger(), 'appium');
//# sourceMappingURL=logger.js.map