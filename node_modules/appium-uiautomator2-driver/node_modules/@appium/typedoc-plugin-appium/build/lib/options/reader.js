"use strict";
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _AppiumPluginOptionsReader_instances, _AppiumPluginOptionsReader_log, _AppiumPluginOptionsReader_configureEntryPointStrategy, _AppiumPluginOptionsReader_configureEntryPoints, _AppiumPluginOptionsReader_configurePackages, _AppiumPluginOptionsReader_configureTheme;
Object.defineProperty(exports, "__esModule", { value: true });
exports.AppiumPluginOptionsReader = void 0;
const lodash_1 = __importDefault(require("lodash"));
const node_path_1 = __importDefault(require("node:path"));
const typedoc_1 = require("typedoc");
const theme_1 = require("../theme");
/**
 * List of theme names to override.
 *
 * `default` is what happens if the user does not specify a theme. The markdown plugin,
 * if loaded, will overwrite `default` with `markdown`, so we'll have to overwrite it again.
 *
 * @internal
 */
const OVERRIDE_THEME_NAMES = new Set(['default', 'markdown']);
/**
 * These packages must be resolvable for the plugin to work at all.
 * @internal
 */
const REQUIRED_PACKAGES = new Set(['@appium/base-driver', '@appium/types']);
/**
 * This befouls the options.
 *
 * It can do what has been undone and undo what has been done. It can make real your dreams... or nightmares.
 */
class AppiumPluginOptionsReader {
    constructor(logger) {
        _AppiumPluginOptionsReader_instances.add(this);
        _AppiumPluginOptionsReader_log.set(this, void 0);
        /**
         * I don't know the point of `name`, but the interface requires it, so here.
         */
        this.name = 'naughty-appium-options-reader';
        /**
         * This needs to be higher than the value in `MarkdownOptionsReader`.
         */
        this.priority = 2000;
        __classPrivateFieldSet(this, _AppiumPluginOptionsReader_log, logger.createChildLogger('options-reader'), "f");
    }
    /**
     * Attempts to derive a title (for use in theme output) from a package's `package.json` if that package is an Appium extension
     * @param pkgJsonPath Path to a `package.json`
     */
    static getTitleFromPackageJson(pkgJsonPath) {
        try {
            // eslint-disable-next-line @typescript-eslint/no-var-requires
            const pkg = require(pkgJsonPath);
            return pkg?.appium?.driverName ?? pkg?.appium?.pluginName;
        }
        catch {
            // ignored
        }
    }
    /**
     * Calls various private methods to override option values or provide defaults.
     * @param container - Options container
     */
    read(container) {
        __classPrivateFieldGet(this, _AppiumPluginOptionsReader_instances, "m", _AppiumPluginOptionsReader_configureTheme).call(this, container);
        __classPrivateFieldGet(this, _AppiumPluginOptionsReader_instances, "m", _AppiumPluginOptionsReader_configureEntryPointStrategy).call(this, container);
        __classPrivateFieldGet(this, _AppiumPluginOptionsReader_instances, "m", _AppiumPluginOptionsReader_configureEntryPoints).call(this, container);
        __classPrivateFieldGet(this, _AppiumPluginOptionsReader_instances, "m", _AppiumPluginOptionsReader_configurePackages).call(this, container);
    }
}
exports.AppiumPluginOptionsReader = AppiumPluginOptionsReader;
_AppiumPluginOptionsReader_log = new WeakMap(), _AppiumPluginOptionsReader_instances = new WeakSet(), _AppiumPluginOptionsReader_configureEntryPointStrategy = function _AppiumPluginOptionsReader_configureEntryPointStrategy(container) {
    const entryPointStrategy = container.getValue('entryPointStrategy');
    if (entryPointStrategy !== typedoc_1.EntryPointStrategy.Packages) {
        container.setValue('entryPointStrategy', typedoc_1.EntryPointStrategy.Packages);
        __classPrivateFieldGet(this, _AppiumPluginOptionsReader_log, "f").verbose('Set option "entryPointStrategy" to "%s"', typedoc_1.EntryPointStrategy.Packages);
    }
}, _AppiumPluginOptionsReader_configureEntryPoints = function _AppiumPluginOptionsReader_configureEntryPoints(container) {
    let entryPoints = container.getValue('entryPoints');
    const newEntryPoints = new Set(entryPoints);
    const addEntryPoint = (entryPoint) => {
        try {
            const entryPointPath = node_path_1.default.dirname(require.resolve(`${entryPoint}/package.json`));
            newEntryPoints.add(entryPointPath);
            __classPrivateFieldGet(this, _AppiumPluginOptionsReader_log, "f").verbose('Added %s to "entryPoint" option', entryPointPath);
        }
        catch (err) {
            __classPrivateFieldGet(this, _AppiumPluginOptionsReader_log, "f").error('Could not find required package "%s"', entryPoint);
        }
    };
    for (const reqdEntryPoint of REQUIRED_PACKAGES) {
        const foundReqdEP = entryPoints.find((entryPoint) => entryPoint.includes(reqdEntryPoint));
        if (foundReqdEP) {
            try {
                require.resolve(foundReqdEP);
                __classPrivateFieldGet(this, _AppiumPluginOptionsReader_log, "f").verbose('entryPoint %s already exists (%s)', reqdEntryPoint, foundReqdEP);
            }
            catch {
                newEntryPoints.delete(foundReqdEP);
                addEntryPoint(reqdEntryPoint);
                __classPrivateFieldGet(this, _AppiumPluginOptionsReader_log, "f").warn('"entryPoint" option item matching required package "%s" is invalid or missing (%s); it was replaced', reqdEntryPoint, foundReqdEP);
            }
        }
        else {
            addEntryPoint(reqdEntryPoint);
        }
    }
    entryPoints = [...newEntryPoints];
    container.setValue('entryPoints', entryPoints);
    __classPrivateFieldGet(this, _AppiumPluginOptionsReader_log, "f").verbose('Final value of "entryPoints" option: %O', entryPoints);
}, _AppiumPluginOptionsReader_configurePackages = function _AppiumPluginOptionsReader_configurePackages(container) {
    let pkgTitles = container.getValue('packageTitles');
    const entryPoints = container.getValue('entryPoints');
    const newPkgTitles = [];
    for (const entryPoint of entryPoints) {
        const pkgJsonPath = require.resolve(`${entryPoint}/package.json`);
        try {
            // eslint-disable-next-line @typescript-eslint/no-var-requires
            const pkg = require(pkgJsonPath);
            const { name } = pkg;
            let title;
            if (pkg.appium?.driverName) {
                title = `Driver: ${pkg.appium.driverName}`;
            }
            else if (pkg.appium?.pluginName) {
                title = `Plugin: ${pkg.appium.pluginName}`;
            }
            if (title && !lodash_1.default.find(pkgTitles, { name })) {
                newPkgTitles.push({ name, title });
            }
        }
        catch {
            __classPrivateFieldGet(this, _AppiumPluginOptionsReader_log, "f").warn('Could not resolve package.json for %s', entryPoint);
        }
    }
    pkgTitles = [...pkgTitles, ...newPkgTitles];
    container.setValue('packageTitles', pkgTitles);
    __classPrivateFieldGet(this, _AppiumPluginOptionsReader_log, "f").verbose('Final value of "packageTitles" option: %O', pkgTitles);
}, _AppiumPluginOptionsReader_configureTheme = function _AppiumPluginOptionsReader_configureTheme(container) {
    if (OVERRIDE_THEME_NAMES.has(container.getValue('theme'))) {
        container.setValue('theme', theme_1.THEME_NAME);
        __classPrivateFieldGet(this, _AppiumPluginOptionsReader_log, "f").verbose('Set option "theme" to "appium"');
    }
};
//# sourceMappingURL=reader.js.map