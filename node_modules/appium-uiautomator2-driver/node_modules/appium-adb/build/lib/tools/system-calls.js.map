{"version":3,"file":"system-calls.js","names":["_path","_interopRequireDefault","require","_logger","_bluebird","_support","_helpers","_teen_process","_asyncbox","_lodash","_semver","systemCallMethods","DEFAULT_ADB_REBOOT_RETRIES","LINKER_WARNING_REGEXP","ADB_RETRY_ERROR_PATTERNS","BINARY_VERSION_PATTERN","BRIDGE_VERSION_PATTERN","CERTS_ROOT","SDK_BINARY_ROOTS","MIN_DELAY_ADB_API_LEVEL","REQUIRED_SERVICES","getSdkBinaryPath","binaryName","getBinaryFromSdkRoot","getBinaryNameForOS","_","memoize","getBinaryNameForOSMemorize","system","isWindows","includes","path","extname","binaries","fullBinaryName","binaryLocs","getSdkBinaryLocationCandidates","sdkRoot","buildToolsDirs","getBuildToolsDirs","buildToolsVersion","filter","x","basename","isEmpty","log","info","push","flatten","map","dir","resolve","binaryLoc","loc","fs","exists","isNull","Error","JSON","stringify","isArray","getAndroidBinaryPath","getSdkRootFromEnv","getBinaryFromPath","which","e","getConnectedDevices","opts","debug","args","executable","defaultArgs","verbose","stdout","exec","message","listHeader","startingIndex","indexOf","slice","excludedLines","allowOfflineDevices","devices","split","trim","line","some","udid","state","description","device","entry","key","value","getDevicesWithRetry","timeoutMs","timer","timing","Timer","start","getDevices","getDuration","asMilliSeconds","toFixed","length","ign","reconnect","restartAdb","sleep","target","adbExec","stderr","suppressKillServer","killServer","error","adbPort","exclusive","resetTelnetAuthToken","homeFolderPath","process","env","platform","warn","dstPath","writeFile","adbExecEmu","cmd","verifyEmulatorConnected","isExecLocked","EXEC_OUTPUT_FORMAT","Object","freeze","STDOUT","FULL","cloneDeep","timeout","adbExecTimeout","DEFAULT_ADB_EXEC_TIMEOUT","timeoutCapName","outputFormat","adbRetried","execFunc","find","arg","test","util","quote","join","replace","errText","p","code","waitForCondition","waitMs","Number","MAX_SAFE_INTEGER","intervalMs","shell","privileged","cmdArr","fullCmd","isRoot","createSubProcess","SubProcess","getAdbPath","getAdbServerPort","getEmulatorPort","emulatorPort","port","getPortFromEmulatorString","emStr","portPattern","parseInt","getConnectedEmulators","emulators","pluralize","setEmulatorPort","emPort","setDeviceId","deviceId","curDeviceId","argsHasDevice","splice","setDevice","deviceObj","getRunningAVD","avdName","emulator","runningAVDName","execEmuConsoleCommand","execTimeout","connTimeout","toLower","getRunningAVDWithRetry","killAllEmulators","killEmulator","hasValue","isEmulatorConnected","launchAVD","language","country","launchTimeout","readyTimeout","retryTimes","emulatorBinaryPath","substr","checkAvdExist","launchArgs","toAvdLocaleArgs","isDelayAdbFeatureEnabled","allowDelayAdb","revision","getEmuVersionInfo","compareVersions","getEmuImageProperties","apiMatch","shellParse","proc","assign","on","Boolean","signal","retry","waitForEmulatorReady","getVersion","result","binaryVersionMatch","binary","version","semver","coerce","build","bridgeVersionMatch","bridge","requiredServicesRe","name","RegExp","services","every","pattern","err","missingServices","zip","waitForDevice","appDeviceReadyTimeout","retries","ping","reboot","wasAlreadyRooted","root","B","delay","setDeviceProperty","unroot","retryInterval","getDeviceProperty","msg","changeUserPrivileges","isElevated","retryIfOffline","cmdFunc","toLowerCase","isSuccessful","fileExists","remotePath","passFlag","checkCmd","ls","lines","l","fileSize","files","match","isNaN","installMitmCertificate","cert","openSsl","getOpenSslForOs","isBuffer","Buffer","from","tmpRoot","tempDir","openDir","srcCert","certHash","dstCertContent","concat","dstCert","rimraf","isMitmCertificateInstalled","tmpCert","posix","_default","exports","default"],"sources":["../../../lib/tools/system-calls.js"],"sourcesContent":["import path from 'path';\nimport log from '../logger.js';\nimport B from 'bluebird';\nimport { system, fs, util, tempDir, timing } from '@appium/support';\nimport {\n  getBuildToolsDirs, toAvdLocaleArgs,\n  getOpenSslForOs, DEFAULT_ADB_EXEC_TIMEOUT, getSdkRootFromEnv\n} from '../helpers';\nimport { exec, SubProcess } from 'teen_process';\nimport { sleep, retry, retryInterval, waitForCondition } from 'asyncbox';\nimport _ from 'lodash';\nimport semver from 'semver';\n\n\nlet systemCallMethods = {};\n\nconst DEFAULT_ADB_REBOOT_RETRIES = 90;\nconst LINKER_WARNING_REGEXP = /^WARNING: linker.+$/m;\nconst ADB_RETRY_ERROR_PATTERNS = [\n  /protocol fault \\(no status\\)/i,\n  /error: device ('.+' )?not found/i,\n  /error: device still connecting/i,\n];\nconst BINARY_VERSION_PATTERN = /^Version ([\\d.]+)-(\\d+)/m;\nconst BRIDGE_VERSION_PATTERN = /^Android Debug Bridge version ([\\d.]+)/m;\nconst CERTS_ROOT = '/system/etc/security/cacerts';\nconst SDK_BINARY_ROOTS = [\n  'platform-tools',\n  'emulator',\n  ['cmdline-tools', 'latest', 'bin'],\n  'tools',\n  ['tools', 'bin'],\n  '.' // Allow custom sdkRoot to specify full folder path\n];\nconst MIN_DELAY_ADB_API_LEVEL = 28;\nconst REQUIRED_SERVICES = ['activity', 'package', 'mount'];\n\n/**\n * Retrieve full path to the given binary.\n *\n * @param {string} binaryName - The name of the binary.\n * @return {string} Full path to the given binary including current SDK root.\n */\nsystemCallMethods.getSdkBinaryPath = async function getSdkBinaryPath (binaryName) {\n  return await this.getBinaryFromSdkRoot(binaryName);\n};\n\n/**\n * Retrieve full binary name for the current operating system as memotize.\n *\n * @param {string} binaryName - simple binary name, for example 'android'.\n * @return {string} Formatted binary name depending on the current platform,\n *                  for example, 'android.bat' on Windows.\n */\nsystemCallMethods.getBinaryNameForOS = _.memoize(function getBinaryNameForOSMemorize (binaryName) {\n  return getBinaryNameForOS(binaryName);\n});\n\n/**\n * Retrieve full binary name for the current operating system.\n *\n * @param {string} binaryName - simple binary name, for example 'android'.\n * @return {string} Formatted binary name depending on the current platform,\n *                  for example, 'android.bat' on Windows.\n */\nfunction getBinaryNameForOS (binaryName) {\n  if (!system.isWindows()) {\n    return binaryName;\n  }\n\n  if (['android', 'apksigner', 'apkanalyzer'].includes(binaryName)) {\n    return `${binaryName}.bat`;\n  }\n  if (!path.extname(binaryName)) {\n    return `${binaryName}.exe`;\n  }\n  return binaryName;\n}\n\n/**\n * Retrieve full path to the given binary and caches it into `binaries`\n * property of the current ADB instance.\n *\n * @param {string} binaryName - Simple name of a binary file.\n * @return {string} Full path to the given binary. The method tries\n *                  to enumerate all the known locations where the binary\n *                  might be located and stops the search as soon as the first\n *                  match is found on the local file system.\n * @throws {Error} If the binary with given name is not present at any\n *                 of known locations or Android SDK is not installed on the\n *                 local file system.\n */\nsystemCallMethods.getBinaryFromSdkRoot = async function getBinaryFromSdkRoot (binaryName) {\n  if (this.binaries[binaryName]) {\n    return this.binaries[binaryName];\n  }\n  const fullBinaryName = this.getBinaryNameForOS(binaryName);\n  const binaryLocs = getSdkBinaryLocationCandidates(this.sdkRoot, fullBinaryName);\n\n  // get subpaths for currently installed build tool directories\n  let buildToolsDirs = await getBuildToolsDirs(this.sdkRoot);\n  if (this.buildToolsVersion) {\n    buildToolsDirs = buildToolsDirs\n      .filter((x) => path.basename(x) === this.buildToolsVersion);\n    if (_.isEmpty(buildToolsDirs)) {\n      log.info(`Found no build tools whose version matches to '${this.buildToolsVersion}'`);\n    } else {\n      log.info(`Using build tools at '${buildToolsDirs}'`);\n    }\n  }\n  binaryLocs.push(...(_.flatten(buildToolsDirs\n    .map((dir) => [\n      path.resolve(dir, fullBinaryName),\n      path.resolve(dir, 'lib', fullBinaryName),\n    ]))\n  ));\n\n  let binaryLoc = null;\n  for (const loc of binaryLocs) {\n    if (await fs.exists(loc)) {\n      binaryLoc = loc;\n      break;\n    }\n  }\n  if (_.isNull(binaryLoc)) {\n    throw new Error(`Could not find '${fullBinaryName}' in ${JSON.stringify(binaryLocs)}. ` +\n      `Do you have Android Build Tools ${this.buildToolsVersion ? `v ${this.buildToolsVersion} ` : ''}` +\n      `installed at '${this.sdkRoot}'?`);\n  }\n  log.info(`Using '${fullBinaryName}' from '${binaryLoc}'`);\n  this.binaries[binaryName] = binaryLoc;\n  return binaryLoc;\n};\n\n/**\n *  Returns the Android binaries locations\n *\n * @param {string} sdkRoot The path to Android SDK root.\n * @param {string} fullBinaryName The name of full binary name.\n * @return {Array<string>} The list of SDK_BINARY_ROOTS paths\n *                          with sdkRoot and fullBinaryName.\n */\nfunction getSdkBinaryLocationCandidates (sdkRoot, fullBinaryName) {\n  return SDK_BINARY_ROOTS.map((x) =>\n    path.resolve(sdkRoot, ...(_.isArray(x) ? x : [x]), fullBinaryName));\n}\n\n/**\n * Retrieve full path to the given binary.\n * This method does not have cache.\n *\n * @param {string} binaryName - Simple name of a binary file.\n *                              e.g. 'adb', 'android'\n * @return {string} Full path to the given binary. The method tries\n *                  to enumerate all the known locations where the binary\n *                  might be located and stops the search as soon as the first\n *                  match is found on the local file system.\n *                  e.g. '/Path/To/Android/sdk/platform-tools/adb'\n * @throws {Error} If the binary with given name is not present at any\n *                 of known locations or Android SDK is not installed on the\n *                 local file system.\n */\nasync function getAndroidBinaryPath (binaryName) {\n  const fullBinaryName = getBinaryNameForOS(binaryName);\n  const sdkRoot = getSdkRootFromEnv();\n  const binaryLocs = getSdkBinaryLocationCandidates(sdkRoot, fullBinaryName);\n  for (const loc of binaryLocs) {\n    if (await fs.exists(loc)) {\n      return loc;\n    }\n  }\n  throw new Error(`Could not find '${fullBinaryName}' in ${JSON.stringify(binaryLocs)}. ` +\n    `Do you have Android Build Tools installed at '${sdkRoot}'?`);\n}\n\n/**\n * Retrieve full path to a binary file using the standard system lookup tool.\n *\n * @param {string} binaryName - The name of the binary.\n * @return {string} Full path to the binary received from 'which'/'where'\n *                  output.\n * @throws {Error} If lookup tool returns non-zero return code.\n */\nsystemCallMethods.getBinaryFromPath = async function getBinaryFromPath (binaryName) {\n  if (this.binaries[binaryName]) {\n    return this.binaries[binaryName];\n  }\n\n  const fullBinaryName = this.getBinaryNameForOS(binaryName);\n  try {\n    const binaryLoc = await fs.which(fullBinaryName);\n    log.info(`Using '${fullBinaryName}' from '${binaryLoc}'`);\n    this.binaries[binaryName] = binaryLoc;\n    return binaryLoc;\n  } catch (e) {\n    throw new Error(`Could not find '${fullBinaryName}' in PATH. Please set the ANDROID_HOME ` +\n      `or ANDROID_SDK_ROOT environment variables to the correct Android SDK root directory path.`);\n  }\n};\n\n/**\n * @typedef {Object} ConnectedDevicesOptions\n * @property {?boolean} verbose - Whether to get long output, which includes extra properties in each device.\n * Akin to running `adb devices -l`.\n */\n\n/**\n * @typedef {Object} Device\n * @property {string} udid - The device udid.\n * @property {string} state - Current device state, as it is visible in\n *                            _adb devices -l_ output.\n */\n\n/**\n * @typedef {Device} VerboseDevice Additional properties returned when `verbose` is true.\n * @property {string} product - The product codename of the device, such as \"razor\".\n * @property {string} model - The model name of the device, such as \"Nexus_7\".\n * @property {string} device - The device codename, such as \"flow\".\n * @property {?string} usb - Represents the USB port the device is connected to, such as \"1-1\".\n * @property {?string} transport_id - The Transport ID for the device, such as \"1\".\n */\n\n/**\n * Retrieve the list of devices visible to adb.\n *\n * @param {?ConnectedDevicesOptions} opts [{}] - Additional options mapping.\n * @return {Array.<Device>} The list of devices or an empty list if\n *                          no devices are connected.\n * @throws {Error} If there was an error while listing devices.\n */\nsystemCallMethods.getConnectedDevices = async function getConnectedDevices (opts = {}) {\n  log.debug('Getting connected devices');\n  const args = [...this.executable.defaultArgs, 'devices'];\n  if (opts.verbose) {\n    args.push('-l');\n  }\n\n  let stdout;\n  try {\n    ({stdout} = await exec(this.executable.path, args));\n  } catch (e) {\n    throw new Error(`Error while getting connected devices. Original error: ${e.message}`);\n  }\n  const listHeader = 'List of devices';\n  // expecting adb devices to return output as\n  // List of devices attached\n  // emulator-5554\tdevice\n  const startingIndex = stdout.indexOf(listHeader);\n  if (startingIndex < 0) {\n    throw new Error(`Unexpected output while trying to get devices: ${stdout}`);\n  }\n  // slicing output we care about\n  stdout = stdout.slice(startingIndex);\n  let excludedLines = [listHeader, 'adb server', '* daemon'];\n  if (!this.allowOfflineDevices) {\n    excludedLines.push('offline');\n  }\n  const devices = stdout.split('\\n')\n    .map(_.trim)\n    .filter((line) => line && !excludedLines.some((x) => line.includes(x)))\n    .map((line) => {\n      // state is \"device\", afaic\n      const [udid, state, ...description] = line.split(/\\s+/);\n      const device = {udid, state};\n      if (opts.verbose) {\n        for (const entry of description) {\n          if (entry.includes(':')) {\n            // each entry looks like key:value\n            const [key, value] = entry.split(':');\n            device[key] = value;\n          }\n        }\n      }\n      return device;\n    });\n  if (_.isEmpty(devices)) {\n    log.debug('No connected devices have been detected');\n  } else {\n    log.debug(`Connected devices: ${JSON.stringify(devices)}`);\n  }\n  return devices;\n};\n\n/**\n * Retrieve the list of devices visible to adb within the given timeout.\n *\n * @param {number} timeoutMs - The maximum number of milliseconds to get at least\n *                             one list item.\n * @return {Array.<Device>} The list of connected devices.\n * @throws {Error} If no connected devices can be detected within the given timeout.\n */\nsystemCallMethods.getDevicesWithRetry = async function getDevicesWithRetry (timeoutMs = 20000) {\n  const timer = new timing.Timer().start();\n  log.debug('Trying to find a connected android device');\n  const getDevices = async () => {\n    if (timer.getDuration().asMilliSeconds > timeoutMs) {\n      throw new Error(`Could not find a connected Android device in ${timer.getDuration().asMilliSeconds.toFixed(0)}ms.`);\n    }\n    try {\n      const devices = await this.getConnectedDevices();\n      if (devices.length > 0) {\n        return devices;\n      }\n    } catch (ign) {}\n\n    log.debug('Could not find online devices');\n    try {\n      await this.reconnect();\n    } catch (ign) {\n      await this.restartAdb();\n    }\n    // cool down\n    await sleep(200);\n    return await getDevices();\n  };\n  return await getDevices();\n};\n\n/**\n * Kick current connection from host/device side and make it reconnect\n *\n * @param {?string} target [offline] One of possible targets to reconnect:\n * offline, device or null\n * Providing `null` will cause reconnection to happen from the host side.\n *\n * @throws {Error} If either ADB version is too old and does not support this\n * command or there was a failure during reconnect.\n */\nsystemCallMethods.reconnect = async function reconnect (target = 'offline') {\n  log.debug(`Reconnecting adb (target ${target})`);\n\n  const args = ['reconnect'];\n  if (target) {\n    args.push(target);\n  }\n  try {\n    await this.adbExec(args);\n  } catch (e) {\n    throw new Error(`Cannot reconnect adb. Original error: ${e.stderr || e.message}`);\n  }\n};\n\n/**\n * Restart adb server, unless _this.suppressKillServer_ property is true.\n */\nsystemCallMethods.restartAdb = async function restartAdb () {\n  if (this.suppressKillServer) {\n    log.debug(`Not restarting abd since 'suppressKillServer' is on`);\n    return;\n  }\n\n  log.debug('Restarting adb');\n  try {\n    await this.killServer();\n    await this.adbExec(['start-server']);\n  } catch (e) {\n    log.error(`Error killing ADB server, going to see if it's online anyway`);\n  }\n};\n\n/**\n * Kill adb server.\n */\nsystemCallMethods.killServer = async function killServer () {\n  log.debug(`Killing adb server on port '${this.adbPort}'`);\n  await this.adbExec(['kill-server'], {\n    exclusive: true,\n  });\n};\n\n/**\n * Reset Telnet authentication token.\n * @see {@link http://tools.android.com/recent/emulator2516releasenotes} for more details.\n *\n * @returns {boolean} If token reset was successful.\n */\nsystemCallMethods.resetTelnetAuthToken = _.memoize(async function resetTelnetAuthToken () {\n  // The methods is used to remove telnet auth token\n  //\n  const homeFolderPath = process.env[(process.platform === 'win32') ? 'USERPROFILE' : 'HOME'];\n  if (!homeFolderPath) {\n    log.warn(`Cannot find the path to user home folder. Ignoring resetting of emulator's telnet authentication token`);\n    return false;\n  }\n  const dstPath = path.resolve(homeFolderPath, '.emulator_console_auth_token');\n  log.debug(`Overriding ${dstPath} with an empty string to avoid telnet authentication for emulator commands`);\n  try {\n    await fs.writeFile(dstPath, '');\n  } catch (e) {\n    log.warn(`Error ${e.message} while resetting the content of ${dstPath}. Ignoring resetting of emulator's telnet authentication token`);\n    return false;\n  }\n  return true;\n});\n\n/**\n * Execute the given emulator command using _adb emu_ tool.\n *\n * @param {Array.<string>} cmd - The array of rest command line parameters.\n */\nsystemCallMethods.adbExecEmu = async function adbExecEmu (cmd) {\n  await this.verifyEmulatorConnected();\n  await this.resetTelnetAuthToken();\n  await this.adbExec(['emu', ...cmd]);\n};\n\nlet isExecLocked = false;\n\nsystemCallMethods.EXEC_OUTPUT_FORMAT = Object.freeze({\n  STDOUT: 'stdout',\n  FULL: 'full',\n});\n\n/**\n * @typedef {Object} ExecResult\n * @property {string} stdout The stdout received from exec\n * @property {string} stderr The stderr received from exec\n */\n\n/**\n * Execute the given adb command.\n *\n * @param {Array.<string>} cmd - The array of rest command line parameters\n *                      or a single string parameter.\n * @param {Object} opts - Additional options mapping. See\n *                        {@link https://github.com/appium/node-teen_process}\n *                        for more details.\n *                        You can also set the additional `exclusive` param\n *                        to `true` that assures no other parallel adb commands\n *                        are going to be executed while the current one is running\n *                        You can set the `outputFormat` param to `stdout` to receive just the stdout\n *                        output (default) or `full` to receive the stdout and stderr response from a\n *                        command with a zero exit code\n * @return {string|ExecResult} - Command's stdout or an object containing stdout and stderr.\n * @throws {Error} If the command returned non-zero exit code.\n */\nsystemCallMethods.adbExec = async function adbExec (cmd, opts = {}) {\n  if (!cmd) {\n    throw new Error('You need to pass in a command to adbExec()');\n  }\n\n  opts = _.cloneDeep(opts);\n  // setting default timeout for each command to prevent infinite wait.\n  opts.timeout = opts.timeout || this.adbExecTimeout || DEFAULT_ADB_EXEC_TIMEOUT;\n  opts.timeoutCapName = opts.timeoutCapName || 'adbExecTimeout'; // For error message\n\n  const {outputFormat = this.EXEC_OUTPUT_FORMAT.STDOUT} = opts;\n\n  cmd = _.isArray(cmd) ? cmd : [cmd];\n  let adbRetried = false;\n  const execFunc = async () => {\n    try {\n      const args = [...this.executable.defaultArgs, ...cmd];\n      log.debug(`Running '${this.executable.path} ` +\n        (args.find((arg) => /\\s+/.test(arg)) ? util.quote(args) : args.join(' ')) + `'`);\n      let {stdout, stderr} = await exec(this.executable.path, args, opts);\n      // sometimes ADB prints out weird stdout warnings that we don't want\n      // to include in any of the response data, so let's strip it out\n      stdout = stdout.replace(LINKER_WARNING_REGEXP, '').trim();\n      return outputFormat === this.EXEC_OUTPUT_FORMAT.FULL ? {stdout, stderr} : stdout;\n    } catch (e) {\n      const errText = `${e.message}, ${e.stdout}, ${e.stderr}`;\n      if (ADB_RETRY_ERROR_PATTERNS.some((p) => p.test(errText))) {\n        log.info(`Error sending command, reconnecting device and retrying: ${cmd}`);\n        await sleep(1000);\n        await this.getDevicesWithRetry();\n\n        // try again one time\n        if (adbRetried) {\n          adbRetried = true;\n          return await execFunc();\n        }\n      }\n\n      if (e.code === 0 && e.stdout) {\n        return e.stdout.replace(LINKER_WARNING_REGEXP, '').trim();\n      }\n\n      if (_.isNull(e.code)) {\n        e.message = `Error executing adbExec. Original error: '${e.message}'. ` +\n          `Try to increase the ${opts.timeout}ms adb execution timeout represented by '${opts.timeoutCapName}' capability`;\n      } else {\n        e.message = `Error executing adbExec. Original error: '${e.message}'; ` +\n          `Command output: ${e.stderr || e.stdout || '<empty>'}`;\n      }\n      throw e;\n    }\n  };\n\n  if (isExecLocked) {\n    log.debug('Waiting until the other exclusive ADB command is completed');\n    await waitForCondition(() => !isExecLocked, {\n      waitMs: Number.MAX_SAFE_INTEGER,\n      intervalMs: 10,\n    });\n    log.debug('Continuing with the current ADB command');\n  }\n  if (opts.exclusive) {\n    isExecLocked = true;\n  }\n  try {\n    return await execFunc();\n  } finally {\n    if (opts.exclusive) {\n      isExecLocked = false;\n    }\n  }\n};\n\n/**\n * @typedef {Object} ShellExecOptions\n * @property {?string} timeoutCapName [adbExecTimeout] - the name of the corresponding Appium's timeout capability\n * (used in the error messages).\n * @property {?number} timeout [adbExecTimeout] - command execution timeout.\n * @property {?boolean} privileged [falsy] - Whether to run the given command as root.\n * @property {?string} outputFormat [stdout] - Whether response should include full exec output or just stdout.\n *                                             Potential values are full or stdout.\n *\n * All other properties are the same as for `exec` call from {@link https://github.com/appium/node-teen_process}\n * module\n */\n\n/**\n * Execute the given command using _adb shell_ prefix.\n *\n * @param {!Array.<string>|string} cmd - The array of rest command line parameters or a single\n *                                      string parameter.\n * @param {?ShellExecOptions} opts [{}] - Additional options mapping.\n * @return {string} - Command's stdout.\n * @throws {Error} If the command returned non-zero exit code.\n */\nsystemCallMethods.shell = async function shell (cmd, opts = {}) {\n  const {\n    privileged,\n  } = opts;\n\n  const cmdArr = _.isArray(cmd) ? cmd : [cmd];\n  const fullCmd = ['shell'];\n  if (privileged) {\n    log.info(`'adb shell ${util.quote(cmdArr)}' requires root access`);\n    if (await this.isRoot()) {\n      log.info('The device already had root access');\n      fullCmd.push(...cmdArr);\n    } else {\n      fullCmd.push('su', 'root', util.quote(cmdArr));\n    }\n  } else {\n    fullCmd.push(...cmdArr);\n  }\n  return await this.adbExec(fullCmd, opts);\n};\n\nsystemCallMethods.createSubProcess = function createSubProcess (args = []) {\n  // add the default arguments\n  args = [...this.executable.defaultArgs, ...args];\n  log.debug(`Creating ADB subprocess with args: ${JSON.stringify(args)}`);\n  return new SubProcess(this.getAdbPath(), args);\n};\n\n/**\n * Retrieve the current adb port.\n * @todo can probably deprecate this now that the logic is just to read this.adbPort\n * @return {number} The current adb port number.\n */\nsystemCallMethods.getAdbServerPort = function getAdbServerPort () {\n  return this.adbPort;\n};\n\n/**\n * Retrieve the current emulator port from _adb devives_ output.\n *\n * @return {number} The current emulator port.\n * @throws {Error} If there are no connected devices.\n */\nsystemCallMethods.getEmulatorPort = async function getEmulatorPort () {\n  log.debug('Getting running emulator port');\n  if (this.emulatorPort !== null) {\n    return this.emulatorPort;\n  }\n  try {\n    let devices = await this.getConnectedDevices();\n    let port = this.getPortFromEmulatorString(devices[0].udid);\n    if (port) {\n      return port;\n    } else {\n      throw new Error(`Emulator port not found`);\n    }\n  } catch (e) {\n    throw new Error(`No devices connected. Original error: ${e.message}`);\n  }\n};\n\n/**\n * Retrieve the current emulator port by parsing emulator name string.\n *\n * @param {string} emStr - Emulator name string.\n * @return {number|boolean} Either the current emulator port or\n *                          _false_ if port number cannot be parsed.\n */\nsystemCallMethods.getPortFromEmulatorString = function getPortFromEmulatorString (emStr) {\n  let portPattern = /emulator-(\\d+)/;\n  if (portPattern.test(emStr)) {\n    return parseInt(portPattern.exec(emStr)[1], 10);\n  }\n  return false;\n};\n\n/**\n * Retrieve the list of currently connected emulators.\n *\n * @param {?ConnectedDevicesOptions} opts [{}] - Additional options mapping.\n * @return {Array.<Device>} The list of connected devices.\n */\nsystemCallMethods.getConnectedEmulators = async function getConnectedEmulators (opts = {}) {\n  log.debug('Getting connected emulators');\n  try {\n    let devices = await this.getConnectedDevices(opts);\n    let emulators = [];\n    for (let device of devices) {\n      let port = this.getPortFromEmulatorString(device.udid);\n      if (port) {\n        device.port = port;\n        emulators.push(device);\n      }\n    }\n    log.debug(`${util.pluralize('emulator', emulators.length, true)} connected`);\n    return emulators;\n  } catch (e) {\n    throw new Error(`Error getting emulators. Original error: ${e.message}`);\n  }\n};\n\n/**\n * Set _emulatorPort_ property of the current class.\n *\n * @param {number} emPort - The emulator port to be set.\n */\nsystemCallMethods.setEmulatorPort = function setEmulatorPort (emPort) {\n  this.emulatorPort = emPort;\n};\n\n/**\n * Set the identifier of the current device (_this.curDeviceId_).\n *\n * @param {string} - The device identifier.\n */\nsystemCallMethods.setDeviceId = function setDeviceId (deviceId) {\n  log.debug(`Setting device id to ${deviceId}`);\n  this.curDeviceId = deviceId;\n  let argsHasDevice = this.executable.defaultArgs.indexOf('-s');\n  if (argsHasDevice !== -1) {\n    // remove the old device id from the arguments\n    this.executable.defaultArgs.splice(argsHasDevice, 2);\n  }\n  this.executable.defaultArgs.push('-s', deviceId);\n};\n\n/**\n * Set the the current device object.\n *\n * @param {Device} deviceObj - The device object to be set.\n */\nsystemCallMethods.setDevice = function setDevice (deviceObj) {\n  let deviceId = deviceObj.udid;\n  let emPort = this.getPortFromEmulatorString(deviceId);\n  this.setEmulatorPort(emPort);\n  this.setDeviceId(deviceId);\n};\n\n/**\n * Get the object for the currently running emulator.\n * !!! This method has a side effect - it implicitly changes the\n * `deviceId` (only if AVD with a matching name is found)\n * and `emulatorPort` instance properties.\n *\n * @param {string} avdName - Emulator name.\n * @return {?Device} Currently running emulator or _null_.\n */\nsystemCallMethods.getRunningAVD = async function getRunningAVD (avdName) {\n  log.debug(`Trying to find '${avdName}' emulator`);\n  try {\n    const emulators = await this.getConnectedEmulators();\n    for (const emulator of emulators) {\n      this.setEmulatorPort(emulator.port);\n      const runningAVDName = await this.execEmuConsoleCommand(['avd', 'name'], {\n        port: emulator.port,\n        execTimeout: 5000,\n        connTimeout: 1000,\n      });\n      if (_.toLower(avdName) === _.toLower(runningAVDName.trim())) {\n        log.debug(`Found emulator '${avdName}' on port ${emulator.port}`);\n        this.setDeviceId(emulator.udid);\n        return emulator;\n      }\n    }\n    log.debug(`Emulator '${avdName}' not running`);\n    return null;\n  } catch (e) {\n    throw new Error(`Error getting AVD. Original error: ${e.message}`);\n  }\n};\n\n/**\n * Get the object for the currently running emulator.\n *\n * @param {string} avdName - Emulator name.\n * @param {number} timeoutMs [20000] - The maximum number of milliseconds\n *                                     to wait until at least one running AVD object\n *                                     is detected.\n * @return {?Device} Currently running emulator or _null_.\n * @throws {Error} If no device has been detected within the timeout.\n */\nsystemCallMethods.getRunningAVDWithRetry = async function getRunningAVDWithRetry (avdName, timeoutMs = 20000) {\n  try {\n    return await waitForCondition(async () => {\n      try {\n        return await this.getRunningAVD(avdName.replace('@', ''));\n      } catch (e) {\n        log.debug(e.message);\n        return false;\n      }\n    }, {\n      waitMs: timeoutMs,\n      intervalMs: 1000,\n    });\n  } catch (e) {\n    throw new Error(`Error getting AVD with retry. Original error: ${e.message}`);\n  }\n};\n\n/**\n * Shutdown all running emulators by killing their processes.\n *\n * @throws {Error} If killing tool returned non-zero return code.\n */\nsystemCallMethods.killAllEmulators = async function killAllEmulators () {\n  let cmd, args;\n  if (system.isWindows()) {\n    cmd = 'TASKKILL';\n    args = ['TASKKILL', '/IM', 'emulator.exe'];\n  } else {\n    cmd = '/usr/bin/killall';\n    args = ['-m', 'emulator*'];\n  }\n  try {\n    await exec(cmd, args);\n  } catch (e) {\n    throw new Error(`Error killing emulators. Original error: ${e.message}`);\n  }\n};\n\n/**\n * Kill emulator with the given name. No error\n * is thrown is given avd does not exist/is not running.\n *\n * @param {?string} avdName - The name of the emulator to be killed. If empty,\n *                            the current emulator will be killed.\n * @param {?number} timeout [60000] - The amount of time to wait before throwing\n *                                    an exception about unsuccessful killing\n * @return {boolean} - True if the emulator was killed, false otherwise.\n * @throws {Error} if there was a failure by killing the emulator\n */\nsystemCallMethods.killEmulator = async function killEmulator (avdName = null, timeout = 60000) {\n  if (util.hasValue(avdName)) {\n    log.debug(`Killing avd '${avdName}'`);\n    const device = await this.getRunningAVD(avdName);\n    if (!device) {\n      log.info(`No avd with name '${avdName}' running. Skipping kill step.`);\n      return false;\n    }\n  } else {\n    // killing the current avd\n    log.debug(`Killing avd with id '${this.curDeviceId}'`);\n    if (!await this.isEmulatorConnected()) {\n      log.debug(`Emulator with id '${this.curDeviceId}' not connected. Skipping kill step`);\n      return false;\n    }\n  }\n  await this.adbExec(['emu', 'kill']);\n  log.debug(`Waiting up to ${timeout}ms until the emulator '${avdName ? avdName : this.curDeviceId}' is killed`);\n  try {\n    await waitForCondition(async () => {\n      try {\n        return util.hasValue(avdName)\n          ? !await this.getRunningAVD(avdName)\n          : !await this.isEmulatorConnected();\n      } catch (ign) {}\n      return false;\n    }, {\n      waitMs: timeout,\n      intervalMs: 2000,\n    });\n  } catch (e) {\n    throw new Error(`The emulator '${avdName ? avdName : this.curDeviceId}' is still running after being killed ${timeout}ms ago`);\n  }\n  log.info(`Successfully killed the '${avdName ? avdName : this.curDeviceId}' emulator`);\n  return true;\n};\n\n/**\n * @typedef {Object} AvdLaunchOptions\n * @property {string|Array<string>} args Additional emulator command line arguments\n * @property {Object} env Additional emulator environment variables\n * @property {string} language Emulator system language\n * @property {string} country Emulator system country\n * @property {number} launchTimeout [60000] Emulator startup timeout in milliseconds\n * @property {number} readyTimeout [60000] The maximum period of time to wait until Emulator\n * is ready for usage in milliseconds\n * @property {number} retryTimes [1] The maximum number of startup retries\n */\n\n/**\n * Start an emulator with given parameters and wait until it is fully started.\n *\n * @param {string} avdName - The name of an existing emulator.\n * @param {?AvdLaunchOptions} opts\n * @returns {SubProcess} Emulator subprocess instance\n * @throws {Error} If the emulator fails to start within the given timeout.\n */\nsystemCallMethods.launchAVD = async function launchAVD (avdName, opts = {}) {\n  const {\n    args = [],\n    env = {},\n    language,\n    country,\n    launchTimeout = 60000,\n    readyTimeout = 60000,\n    retryTimes = 1,\n  } = opts;\n  log.debug(`Launching Emulator with AVD ${avdName}, launchTimeout ` +\n            `${launchTimeout}ms and readyTimeout ${readyTimeout}ms`);\n  const emulatorBinaryPath = await this.getSdkBinaryPath('emulator');\n  if (avdName[0] === '@') {\n    avdName = avdName.substr(1);\n  }\n  await this.checkAvdExist(avdName);\n\n  const launchArgs = ['-avd', avdName];\n  launchArgs.push(...(toAvdLocaleArgs(language, country)));\n\n  let isDelayAdbFeatureEnabled = false;\n  if (this.allowDelayAdb) {\n    const {revision} = await this.getEmuVersionInfo();\n    if (revision && util.compareVersions(revision, '>=', '29.0.7')) {\n      // https://androidstudio.googleblog.com/2019/05/emulator-2907-canary.html\n      try {\n        const {target} = await this.getEmuImageProperties(avdName);\n        const apiMatch = /\\d+/.exec(target);\n        // https://issuetracker.google.com/issues/142533355\n        if (apiMatch && parseInt(apiMatch[0], 10) >= MIN_DELAY_ADB_API_LEVEL) {\n          launchArgs.push('-delay-adb');\n          isDelayAdbFeatureEnabled = true;\n        } else {\n          throw new Error(`The actual image API version is below ${MIN_DELAY_ADB_API_LEVEL}`);\n        }\n      } catch (e) {\n        log.info(`The -delay-adb emulator startup detection feature will not be enabled. ` +\n          `Original error: ${e.message}`);\n      }\n    }\n  } else {\n    log.info('The -delay-adb emulator startup detection feature has been explicitly disabled');\n  }\n\n  if (!_.isEmpty(args)) {\n    launchArgs.push(...(_.isArray(args) ? args : util.shellParse(`${args}`)));\n  }\n\n  log.debug(`Running '${emulatorBinaryPath}' with args: ${util.quote(launchArgs)}`);\n  if (!_.isEmpty(env)) {\n    log.debug(`Customized emulator environment: ${JSON.stringify(env)}`);\n  }\n  const proc = new SubProcess(emulatorBinaryPath, launchArgs, {\n    env: Object.assign({}, process.env, env),\n  });\n  await proc.start(0);\n  proc.on('output', (stdout, stderr) => {\n    for (let line of (stdout || stderr || '').split('\\n').filter(Boolean)) {\n      log.info(`[AVD OUTPUT] ${line}`);\n    }\n  });\n  proc.on('die', (code, signal) => {\n    log.warn(`Emulator avd ${avdName} exited with code ${code}${signal ? `, signal ${signal}` : ''}`);\n  });\n  await retry(retryTimes, async () => await this.getRunningAVDWithRetry(avdName, launchTimeout));\n  // At this point we have deviceId already assigned\n  const timer = new timing.Timer().start();\n  if (isDelayAdbFeatureEnabled) {\n    try {\n      await this.adbExec(['wait-for-device'], {timeout: readyTimeout});\n    } catch (e) {\n      throw new Error(`'${avdName}' Emulator has failed to boot: ${e.stderr || e.message}`);\n    }\n  }\n  await this.waitForEmulatorReady(readyTimeout - timer.getDuration().asMilliSeconds);\n  return proc;\n};\n\n/**\n * @typedef {Object} BinaryVersion\n * @property {SemVer} version - The ADB binary version number\n * @property {number} build - The ADB binary build number\n */\n\n/**\n * @typedef {Object} BridgeVersion\n * @property {SemVer} version - The Android Debug Bridge version number\n */\n\n/**\n * @typedef {Object} Version\n * @property {?BinaryVersion} binary This version number might not be\n * be present for older ADB releases.\n * @property {BridgeVersion} bridge\n */\n\n/**\n * Get the adb version. The result of this method is cached.\n *\n * @return {Version}\n * @throws {Error} If it is not possible to parse adb binary version.\n */\nsystemCallMethods.getVersion = _.memoize(async function getVersion () {\n  let stdout;\n  try {\n    stdout = await this.adbExec('version');\n  } catch (e) {\n    throw new Error(`Error getting adb version: ${e.stderr || e.message}`);\n  }\n\n  const result = {};\n  const binaryVersionMatch = BINARY_VERSION_PATTERN.exec(stdout);\n  if (binaryVersionMatch) {\n    result.binary = {\n      version: semver.coerce(binaryVersionMatch[1]),\n      build: parseInt(binaryVersionMatch[2], 10),\n    };\n  }\n  const bridgeVersionMatch = BRIDGE_VERSION_PATTERN.exec(stdout);\n  if (bridgeVersionMatch) {\n    result.bridge = {\n      version: semver.coerce(bridgeVersionMatch[1]),\n    };\n  }\n  return result;\n});\n\n/**\n * Check if the current emulator is ready to accept further commands (booting completed).\n *\n * @param {number} timeoutMs [20000] - The maximum number of milliseconds to wait.\n * @throws {Error} If the emulator is not ready within the given timeout.\n */\nsystemCallMethods.waitForEmulatorReady = async function waitForEmulatorReady (timeoutMs = 20000) {\n  const requiredServicesRe = REQUIRED_SERVICES.map((name) => new RegExp(`\\\\b${name}:`));\n  let services;\n  try {\n    await waitForCondition(async () => {\n      try {\n        services = await this.shell(['service', 'list']);\n        return requiredServicesRe.every((pattern) => pattern.test(services));\n      } catch (err) {\n        log.debug(`Waiting for emulator startup. Intermediate error: ${err.message}`);\n        return false;\n      }\n    }, {\n      waitMs: timeoutMs,\n      intervalMs: 3000,\n    });\n  } catch (e) {\n    if (services) {\n      log.debug(`Recently listed services:\\n${services}`);\n    }\n    const missingServices = _.zip(REQUIRED_SERVICES, requiredServicesRe)\n      .filter(([, pattern]) => !pattern.test(services))\n      .map(([name]) => name);\n    throw new Error(`Emulator is not ready within ${timeoutMs}ms ` +\n      `(${missingServices} service${missingServices.length === 1 ? ' is' : 's are'} not running)`);\n  }\n};\n\n/**\n * Check if the current device is ready to accept further commands (booting completed).\n *\n * @param {number} appDeviceReadyTimeout [30] - The maximum number of seconds to wait.\n * @throws {Error} If the device is not ready within the given timeout.\n */\nsystemCallMethods.waitForDevice = async function waitForDevice (appDeviceReadyTimeout = 30) {\n  this.appDeviceReadyTimeout = appDeviceReadyTimeout;\n  const retries = 3;\n  const timeout = parseInt(this.appDeviceReadyTimeout, 10) * 1000 / retries;\n  await retry(retries, async () => {\n    try {\n      await this.adbExec('wait-for-device', {timeout});\n      await this.ping();\n    } catch (e) {\n      try {\n        await this.reconnect();\n      } catch (ign) {\n        await this.restartAdb();\n      }\n      await this.getConnectedDevices();\n      throw new Error(`Error waiting for the device to be available. Original error: '${e.message}'`);\n    }\n  });\n};\n\n/**\n * Reboot the current device and wait until it is completed.\n *\n * @param {number} retries [DEFAULT_ADB_REBOOT_RETRIES] - The maximum number of reboot retries.\n * @throws {Error} If the device failed to reboot and number of retries is exceeded.\n */\nsystemCallMethods.reboot = async function reboot (retries = DEFAULT_ADB_REBOOT_RETRIES) {\n  // Get root access so we can run the next shell commands which require root access\n  const { wasAlreadyRooted } = await this.root();\n  try {\n    // Stop and re-start the device\n    await this.shell(['stop']);\n    await B.delay(2000); // let the emu finish stopping;\n    await this.setDeviceProperty('sys.boot_completed', 0, {\n      privileged: false // no need to set privileged true because device already rooted\n    });\n    await this.shell(['start']);\n  } catch (e) {\n    const {message} = e;\n\n    // provide a helpful error message if the reason reboot failed was because ADB couldn't gain root access\n    if (message.includes('must be root')) {\n      throw new Error(`Could not reboot device. Rebooting requires root access and ` +\n        `attempt to get root access on device failed with error: '${message}'`);\n    }\n    throw e;\n  } finally {\n    // Return root state to what it was before\n    if (!wasAlreadyRooted) {\n      await this.unroot();\n    }\n  }\n  const timer = new timing.Timer().start();\n  await retryInterval(retries, 1000, async () => {\n    if ((await this.getDeviceProperty('sys.boot_completed')) === '1') {\n      return;\n    }\n    // we don't want the stack trace, so no log.errorAndThrow\n    const msg = `Reboot is not completed after ${timer.getDuration().asMilliSeconds.toFixed(0)}ms`;\n    log.debug(msg);\n    throw new Error(msg);\n  });\n};\n\n/**\n * @typedef {Object} rootResult\n * @property {boolean} isSuccessful True if the call to root/unroot was successful\n * @property {boolean} wasAlreadyRooted True if the device was already rooted\n */\n\n/**\n * Switch adb server root privileges.\n * @param {boolean} isElevated - Should we elevate to to root or unroot? (default true)\n * @return {rootResult}\n */\nsystemCallMethods.changeUserPrivileges = async function changeUserPrivileges (isElevated) {\n  const cmd = isElevated ? 'root' : 'unroot';\n\n  const retryIfOffline = async (cmdFunc) => {\n    try {\n      return await cmdFunc();\n    } catch (err) {\n      // Check the output of the stdErr to see if there's any clues that show that the device went offline\n      // and if it did go offline, restart ADB\n      if (['closed', 'device offline', 'timeout expired']\n          .some((x) => (err.stderr || '').toLowerCase().includes(x))) {\n        log.warn(`Attempt to ${cmd} caused ADB to think the device went offline`);\n        try {\n          await this.reconnect();\n        } catch (ign) {\n          await this.restartAdb();\n        }\n        return await cmdFunc();\n      } else {\n        throw err;\n      }\n    }\n  };\n\n  // If it's already rooted, our job is done. No need to root it again.\n  const isRoot = await retryIfOffline(async () => await this.isRoot());\n  if ((isRoot && isElevated) || (!isRoot && !isElevated)) {\n    return {isSuccessful: true, wasAlreadyRooted: isRoot};\n  }\n\n  let wasAlreadyRooted = isRoot;\n  try {\n    const {stdout} = await retryIfOffline(async () => await this.adbExec([cmd]));\n    log.debug(stdout);\n\n    // on real devices in some situations we get an error in the stdout\n    if (stdout) {\n      if (stdout.includes('adbd cannot run as root')) {\n        return {isSuccessful: false, wasAlreadyRooted};\n      }\n      // if the device was already rooted, return that in the result\n      if (stdout.includes('already running as root')) {\n        wasAlreadyRooted = true;\n      }\n    }\n    return {isSuccessful: true, wasAlreadyRooted};\n  } catch (err) {\n    const {stderr = '', message} = err;\n    log.warn(`Unable to ${cmd} adb daemon. Original error: '${message}'. Stderr: '${stderr}'. Continuing.`);\n    return {isSuccessful: false, wasAlreadyRooted};\n  }\n};\n\n/**\n * Switch adb server to root mode\n * @return {rootResult}\n */\nsystemCallMethods.root = async function root () {\n  return await this.changeUserPrivileges(true);\n};\n\n/**\n * Switch adb server to non-root mode.\n *\n * @return {rootResult}\n */\nsystemCallMethods.unroot = async function unroot () {\n  return await this.changeUserPrivileges(false);\n};\n\n/**\n * Checks whether the current user is root\n *\n * @return {boolean} True if the user is root\n * @throws {Error} if there was an error while identifying\n * the user.\n */\nsystemCallMethods.isRoot = async function isRoot () {\n  return (await this.shell(['whoami'])).trim() === 'root';\n};\n\n/**\n * Verify whether a remote path exists on the device under test.\n *\n * @param {string} remotePath - The remote path to verify.\n * @return {boolean} True if the given path exists on the device.\n */\nsystemCallMethods.fileExists = async function fileExists (remotePath) {\n  const passFlag = '__PASS__';\n  const checkCmd = `[ -e '${remotePath.replace(/'/g, `\\\\'`)}' ] && echo ${passFlag}`;\n  try {\n    return _.includes(await this.shell([checkCmd]), passFlag);\n  } catch (ign) {\n    return false;\n  }\n};\n\n/**\n * Get the output of _ls_ command on the device under test.\n *\n * @param {string} remotePath - The remote path (the first argument to the _ls_ command).\n * @param {Array.<String>} opts [[]] - Additional _ls_ options.\n * @return {Array.<String>} The _ls_ output as an array of split lines.\n *                          An empty array is returned of the given _remotePath_\n *                          does not exist.\n */\nsystemCallMethods.ls = async function ls (remotePath, opts = []) {\n  try {\n    let args = ['ls', ...opts, remotePath];\n    let stdout = await this.shell(args);\n    let lines = stdout.split('\\n');\n    return lines.map((l) => l.trim())\n      .filter(Boolean)\n      .filter((l) => l.indexOf('No such file') === -1);\n  } catch (err) {\n    if (err.message.indexOf('No such file or directory') === -1) {\n      throw err;\n    }\n    return [];\n  }\n};\n\n/**\n * Get the size of the particular file located on the device under test.\n *\n * @param {string} remotePath - The remote path to the file.\n * @return {number} File size in bytes.\n * @throws {Error} If there was an error while getting the size of the given file.\n */\nsystemCallMethods.fileSize = async function fileSize (remotePath) {\n  try {\n    const files = await this.ls(remotePath, ['-la']);\n    if (files.length !== 1) {\n      throw new Error(`Remote path is not a file`);\n    }\n    // https://regex101.com/r/fOs4P4/8\n    const match = /[rwxsStT\\-+]{10}[\\s\\d]*\\s[^\\s]+\\s+[^\\s]+\\s+(\\d+)/.exec(files[0]);\n    if (!match || _.isNaN(parseInt(match[1], 10))) {\n      throw new Error(`Unable to parse size from list output: '${files[0]}'`);\n    }\n    return parseInt(match[1], 10);\n  } catch (err) {\n    throw new Error(`Unable to get file size for '${remotePath}': ${err.message}`);\n  }\n};\n\n/**\n * Installs the given certificate on a rooted real device or\n * an emulator. The emulator must be executed with `-writable-system`\n * command line option and adb daemon should be running in root\n * mode for this method to work properly. The method also requires\n * openssl tool to be available on the destination system.\n * Read https://github.com/appium/appium/issues/10964\n * for more details on this topic\n *\n * @param {Buffer|string} cert - base64-decoded content of the actual certificate\n * represented as a string or a buffer\n * @throws {Error} If openssl tool is not available on the destination system\n * or if there was an error while installing the certificate\n */\nsystemCallMethods.installMitmCertificate = async function installMitmCertificate (cert) {\n  const openSsl = await getOpenSslForOs();\n\n  if (!_.isBuffer(cert)) {\n    cert = Buffer.from(cert, 'base64');\n  }\n\n  const tmpRoot = await tempDir.openDir();\n  try {\n    const srcCert = path.resolve(tmpRoot, 'source.cer');\n    await fs.writeFile(srcCert, cert);\n    let {stdout} = await exec(openSsl, ['x509', '-noout', '-hash', '-in', srcCert]);\n    const certHash = stdout.trim();\n    log.debug(`Got certificate hash: ${certHash}`);\n    log.debug('Preparing certificate content');\n    ({stdout} = await exec(openSsl, ['x509', '-in', srcCert], {isBuffer: true}));\n    let dstCertContent = stdout;\n    ({stdout} = await exec(openSsl, ['x509',\n      '-in', srcCert,\n      '-text',\n      '-fingerprint',\n      '-noout'], {isBuffer: true}));\n    dstCertContent = Buffer.concat([dstCertContent, stdout]);\n    const dstCert = path.resolve(tmpRoot, `${certHash}.0`);\n    await fs.writeFile(dstCert, dstCertContent);\n    log.debug('Remounting /system in rw mode');\n    // Sometimes emulator reboot is still not fully finished on this stage, so retry\n    await retryInterval(5, 2000, async () => await this.adbExec(['remount']));\n    log.debug(`Uploading the generated certificate from '${dstCert}' to '${CERTS_ROOT}'`);\n    await this.push(dstCert, CERTS_ROOT);\n    log.debug('Remounting /system to confirm changes');\n    await this.adbExec(['remount']);\n  } catch (err) {\n    throw new Error(`Cannot inject the custom certificate. ` +\n                    `Is the certificate properly encoded into base64-string? ` +\n                    `Do you have root permissions on the device? ` +\n                    `Original error: ${err.message}`);\n  } finally {\n    await fs.rimraf(tmpRoot);\n  }\n};\n\n/**\n * Verifies if the given root certificate is already installed on the device.\n *\n * @param {Buffer|string} cert - base64-decoded content of the actual certificate\n * represented as a string or a buffer\n * @throws {Error} If openssl tool is not available on the destination system\n * or if there was an error while checking the certificate\n * @returns {boolean} true if the given certificate is already installed\n */\nsystemCallMethods.isMitmCertificateInstalled = async function isMitmCertificateInstalled (cert) {\n  const openSsl = await getOpenSslForOs();\n\n  if (!_.isBuffer(cert)) {\n    cert = Buffer.from(cert, 'base64');\n  }\n\n  const tmpRoot = await tempDir.openDir();\n  let certHash;\n  try {\n    const tmpCert = path.resolve(tmpRoot, 'source.cer');\n    await fs.writeFile(tmpCert, cert);\n    const {stdout} = await exec(openSsl, ['x509', '-noout', '-hash', '-in', tmpCert]);\n    certHash = stdout.trim();\n  } catch (err) {\n    throw new Error(`Cannot retrieve the certificate hash. ` +\n                    `Is the certificate properly encoded into base64-string? ` +\n                    `Original error: ${err.message}`);\n  } finally {\n    await fs.rimraf(tmpRoot);\n  }\n  const dstPath = path.posix.resolve(CERTS_ROOT, `${certHash}.0`);\n  log.debug(`Checking if the certificate is already installed at '${dstPath}'`);\n  return await this.fileExists(dstPath);\n};\n\nexport default systemCallMethods;\nexport { DEFAULT_ADB_EXEC_TIMEOUT, getAndroidBinaryPath };\n"],"mappings":"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"}