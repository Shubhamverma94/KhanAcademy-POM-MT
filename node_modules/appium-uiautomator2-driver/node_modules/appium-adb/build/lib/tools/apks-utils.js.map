{"version":3,"file":"apks-utils.js","names":["_teen_process","require","_logger","_interopRequireDefault","_path","_lodash","_support","_lruCache","_helpers","_asyncLock","_bluebird","BASE_APK","LANGUAGE_APK","lang","APKS_CACHE","LRU","max","dispose","apksHash","extractedFilesRoot","fs","rimraf","APKS_CACHE_GUARD","AsyncLock","BUNDLETOOL_TIMEOUT_MS","apksUtilsMethods","process","on","size","paths","values","log","debug","length","util","pluralize","appPath","rimrafSync","e","warn","message","extractFromApks","apks","dstPath","_","isArray","acquire","hash","has","resultPath","path","resolve","get","exists","del","tmpRoot","tempDir","openDir","unzipFile","Error","join","sep","set","execBundletool","args","errorMsg","initBundletool","binaries","bundletool","env","adbPort","ANDROID_ADB_SERVER_PORT","adbHost","ANDROID_ADB_SERVER_HOST","JSON","stringify","stdout","exec","getJavaForOs","timeout","truncate","stderr","getDeviceSpec","specLocation","executable","curDeviceId","installMultipleApks","apkPathsToInstall","options","installArgs","buildInstallArgs","getApiLevel","adbExec","timeoutCapName","installApks","grantPermissions","allowTestPackages","APKS_INSTALL_TIMEOUT","push","tasks","basename","getApkInfo","apkInfo","B","all","grantAllPermissions","name","extractBaseApk","extractLanguageApk","language","info","defaultLanguages","ign","isTestPackageOnlyError","output","test","_default","exports","default"],"sources":["../../../lib/tools/apks-utils.js"],"sourcesContent":["import { exec } from 'teen_process';\nimport log from '../logger.js';\nimport path from 'path';\nimport _ from 'lodash';\nimport { fs, tempDir, util } from '@appium/support';\nimport LRU from 'lru-cache';\nimport {\n  getJavaForOs, unzipFile, buildInstallArgs, APKS_INSTALL_TIMEOUT\n} from '../helpers.js';\nimport AsyncLock from 'async-lock';\nimport B from 'bluebird';\n\nconst BASE_APK = 'base-master.apk';\nconst LANGUAGE_APK = (lang) => `base-${lang}.apk`;\nconst APKS_CACHE = new LRU({\n  max: 10,\n  dispose: (apksHash, extractedFilesRoot) => fs.rimraf(extractedFilesRoot),\n});\nconst APKS_CACHE_GUARD = new AsyncLock();\nconst BUNDLETOOL_TIMEOUT_MS = 4 * 60 * 1000;\n\nconst apksUtilsMethods = {};\n\nprocess.on('exit', () => {\n  if (!APKS_CACHE.size) {\n    return;\n  }\n\n  const paths = [...APKS_CACHE.values()];\n  log.debug(`Performing cleanup of ${paths.length} cached .apks ` +\n    util.pluralize('package', paths.length));\n  for (const appPath of paths) {\n    try {\n      // Asynchronous calls are not supported in onExit handler\n      fs.rimrafSync(appPath);\n    } catch (e) {\n      log.warn(e.message);\n    }\n  }\n});\n\n/**\n * Extracts the particular apks package into a temporary folder,\n * finds and returns the full path to the file contained in this apk.\n * The resulting temporary path, where the .apks file has been extracted,\n * will be stored into the internal LRU cache for better performance.\n *\n * @param {string} apks - The full path to the .apks file\n * @param {string|Array<String>} dstPath - The relative path to the destination file,\n * which is going to be extracted, where each path component is an array item\n * @returns {string} Full path to the extracted file\n * @throws {Error} If the requested item does not exist in the extracted archive or the provides\n * apks file is not a valid bundle\n */\nasync function extractFromApks (apks, dstPath) {\n  if (!_.isArray(dstPath)) {\n    dstPath = [dstPath];\n  }\n\n  return await APKS_CACHE_GUARD.acquire(apks, async () => {\n    // It might be that the original file has been replaced,\n    // so we need to keep the hash sums instead of the actual file paths\n    // as caching keys\n    const apksHash = await fs.hash(apks);\n    log.debug(`Calculated '${apks}' hash: ${apksHash}`);\n\n    if (APKS_CACHE.has(apksHash)) {\n      const resultPath = path.resolve(APKS_CACHE.get(apksHash), ...dstPath);\n      if (await fs.exists(resultPath)) {\n        return resultPath;\n      }\n      APKS_CACHE.del(apksHash);\n    }\n\n    const tmpRoot = await tempDir.openDir();\n    log.debug(`Unpacking application bundle at '${apks}' to '${tmpRoot}'`);\n    await unzipFile(apks, tmpRoot);\n    const resultPath = path.resolve(tmpRoot, ...dstPath);\n    if (!await fs.exists(resultPath)) {\n      throw new Error(`${dstPath.join(path.sep)} cannot be found in '${apks}' bundle. ` +\n        `Does the archive contain a valid application bundle?`);\n    }\n    APKS_CACHE.set(apksHash, tmpRoot);\n    return resultPath;\n  });\n}\n\n/**\n * Executes bundletool utility with given arguments and returns the actual stdout\n *\n * @param {Array<String>} args - the list of bundletool arguments\n * @param {string} errorMsg - The customized error message string\n * @returns {string} the actual command stdout\n * @throws {Error} If bundletool jar does not exist in PATH or there was an error while\n * executing it\n */\napksUtilsMethods.execBundletool = async function execBundletool (args, errorMsg) {\n  await this.initBundletool();\n  args = [\n    '-jar', this.binaries.bundletool,\n    ...args\n  ];\n  const env = process.env;\n  if (this.adbPort) {\n    env.ANDROID_ADB_SERVER_PORT = `${this.adbPort}`;\n  }\n  if (this.adbHost) {\n    env.ANDROID_ADB_SERVER_HOST = this.adbHost;\n  }\n  log.debug(`Executing bundletool with arguments: ${JSON.stringify(args)}`);\n  let stdout;\n  try {\n    ({stdout} = await exec(await getJavaForOs(), args, {\n      env,\n      timeout: BUNDLETOOL_TIMEOUT_MS,\n    }));\n    log.debug(`Command stdout: ${_.truncate(stdout, {length: 300})}`);\n    return stdout;\n  } catch (e) {\n    if (e.stdout) {\n      log.debug(`Command stdout: ${e.stdout}`);\n    }\n    if (e.stderr) {\n      log.debug(`Command stderr: ${e.stderr}`);\n    }\n    throw new Error(`${errorMsg}. Original error: ${e.message}`);\n  }\n};\n\n/**\n * @param {string} specLocation - The full path to the generated device spec location\n * @returns {string} The same `specLocation` value\n * @throws {Error} If it is not possible to retrieve the spec for the current device\n */\napksUtilsMethods.getDeviceSpec = async function getDeviceSpec (specLocation) {\n  const args = [\n    'get-device-spec',\n    '--adb', this.executable.path,\n    '--device-id', this.curDeviceId,\n    '--output', specLocation,\n  ];\n  log.debug(`Getting the spec for the device '${this.curDeviceId}'`);\n  await this.execBundletool(args, 'Cannot retrieve the device spec');\n  return specLocation;\n};\n\n/**\n * @typedef {Object} InstallMultipleApksOptions\n * @property {?number|string} timeout [20000] - The number of milliseconds to wait until\n * the installation is completed\n * @property {string} timeoutCapName [androidInstallTimeout] - The timeout option name\n * users can increase the timeout.\n * @property {boolean} allowTestPackages [false] - Set to true in order to allow test\n * packages installation.\n * @property {boolean} useSdcard [false] - Set to true to install the app on sdcard\n * instead of the device memory.\n * @property {boolean} grantPermissions [false] - Set to true in order to grant all the\n * permissions requested in the application's manifest automatically after the installation\n * is completed under Android 6+.\n * @property {boolean} partialInstall [false] - Install apks partially. It is used for 'install-multiple'.\n * https://android.stackexchange.com/questions/111064/what-is-a-partial-application-install-via-adb\n */\n\n/**\n * Installs the given apks into the device under test\n *\n * @param {Array<string>} apkPathsToInstall - The full paths to install apks\n * @param {?installMultipleApksOptions} options - Installation options\n */\napksUtilsMethods.installMultipleApks = async function installMultipleApks (apkPathsToInstall, options = {}) {\n  const installArgs = buildInstallArgs(await this.getApiLevel(), options);\n  return await this.adbExec(['install-multiple', ...installArgs, ...apkPathsToInstall], {\n    timeout: options.timeout,\n    timeoutCapName: options.timeoutCapName,\n  });\n};\n\n/**\n * @typedef {Object} InstallApksOptions\n * @property {?number|string} timeout [120000] - The number of milliseconds to wait until\n * the installation is completed\n * @property {string} timeoutCapName [androidInstallTimeout] - The timeout option name\n * users can increase the timeout.\n * @property {boolean} allowTestPackages [false] - Set to true in order to allow test\n * packages installation.\n * @property {boolean} grantPermissions [false] - Set to true in order to grant all the\n * permissions requested in the application's manifest automatically after the installation\n * is completed under Android 6+.\n */\n\n/**\n * Installs the given .apks package into the device under test\n *\n * @param {string} apks - The full path to the .apks file\n * @param {?InstallApksOptions} options - Installation options\n * @throws {Error} If the .apks bundle cannot be installed\n */\napksUtilsMethods.installApks = async function installApks (apks, options = {}) {\n  const {\n    grantPermissions,\n    allowTestPackages,\n    timeout,\n  } = options;\n\n  const args = [\n    'install-apks',\n    '--adb', this.executable.path,\n    '--apks', apks,\n    '--timeout-millis', timeout || APKS_INSTALL_TIMEOUT,\n    '--device-id', this.curDeviceId,\n  ];\n  if (allowTestPackages) {\n    args.push('--allow-test-only');\n  }\n  const tasks = [\n    this.execBundletool(args, `Cannot install '${path.basename(apks)}' to the device ${this.curDeviceId}`)\n  ];\n  if (grantPermissions) {\n    tasks.push(this.getApkInfo(apks));\n  }\n  const [, apkInfo] = await B.all(tasks);\n  if (grantPermissions && apkInfo) {\n    // TODO: Simplify it after https://github.com/google/bundletool/issues/246 is implemented\n    await this.grantAllPermissions(apkInfo.name);\n  }\n};\n\n/**\n * Extracts and returns the full path to the master .apk file inside the bundle.\n *\n * @param {string} apks - The full path to the .apks file\n * @returns {string} The full path to the master bundle .apk\n * @throws {Error} If there was an error while extracting/finding the file\n */\napksUtilsMethods.extractBaseApk = async function extractBaseApk (apks) {\n  return await extractFromApks(apks, ['splits', BASE_APK]);\n};\n\n/**\n * Extracts and returns the full path to the .apk, which contains the corresponding\n * resources for the given language in the .apks bundle.\n *\n * @param {string} apks - The full path to the .apks file\n * @param {?string} language - The language abbreviation. The default language is\n * going to be selected if it is not set.\n * @returns {string} The full path to the corresponding language .apk or the master .apk\n * if language split is not enabled for the bundle.\n * @throws {Error} If there was an error while extracting/finding the file\n */\napksUtilsMethods.extractLanguageApk = async function extractLanguageApk (apks, language = null) {\n  if (language) {\n    try {\n      return await extractFromApks(apks, ['splits', LANGUAGE_APK(language)]);\n    } catch (e) {\n      log.debug(e.message);\n      log.info(`Assuming that splitting by language is not enabled for the '${apks}' bundle ` +\n        `and returning the main apk instead`);\n      return await this.extractBaseApk(apks);\n    }\n  }\n\n  const defaultLanguages = ['en', 'en_us'];\n  for (const lang of defaultLanguages) {\n    try {\n      return await extractFromApks(apks, ['splits', LANGUAGE_APK(lang)]);\n    } catch (ign) {}\n  }\n\n  log.info(`Cannot find any split apk for the default languages ${JSON.stringify(defaultLanguages)}. ` +\n    `Returning the main apk instead.`);\n  return await this.extractBaseApk(apks);\n};\n\napksUtilsMethods.isTestPackageOnlyError = function isTestPackageOnlyError (output) {\n  return /\\[INSTALL_FAILED_TEST_ONLY\\]/.test(output);\n};\n\nexport default apksUtilsMethods;\n"],"mappings":";;;;;;;;AAAA,IAAAA,aAAA,GAAAC,OAAA;AACA,IAAAC,OAAA,GAAAC,sBAAA,CAAAF,OAAA;AACA,IAAAG,KAAA,GAAAD,sBAAA,CAAAF,OAAA;AACA,IAAAI,OAAA,GAAAF,sBAAA,CAAAF,OAAA;AACA,IAAAK,QAAA,GAAAL,OAAA;AACA,IAAAM,SAAA,GAAAJ,sBAAA,CAAAF,OAAA;AACA,IAAAO,QAAA,GAAAP,OAAA;AAGA,IAAAQ,UAAA,GAAAN,sBAAA,CAAAF,OAAA;AACA,IAAAS,SAAA,GAAAP,sBAAA,CAAAF,OAAA;AAEA,MAAMU,QAAQ,GAAG,iBAAiB;AAClC,MAAMC,YAAY,GAAIC,IAAI,IAAM,QAAOA,IAAK,MAAK;AACjD,MAAMC,UAAU,GAAG,IAAIC,iBAAG,CAAC;EACzBC,GAAG,EAAE,EAAE;EACPC,OAAO,EAAEA,CAACC,QAAQ,EAAEC,kBAAkB,KAAKC,WAAE,CAACC,MAAM,CAACF,kBAAkB;AACzE,CAAC,CAAC;AACF,MAAMG,gBAAgB,GAAG,IAAIC,kBAAS,CAAC,CAAC;AACxC,MAAMC,qBAAqB,GAAG,CAAC,GAAG,EAAE,GAAG,IAAI;AAE3C,MAAMC,gBAAgB,GAAG,CAAC,CAAC;AAE3BC,OAAO,CAACC,EAAE,CAAC,MAAM,EAAE,MAAM;EACvB,IAAI,CAACb,UAAU,CAACc,IAAI,EAAE;IACpB;EACF;EAEA,MAAMC,KAAK,GAAG,CAAC,GAAGf,UAAU,CAACgB,MAAM,CAAC,CAAC,CAAC;EACtCC,eAAG,CAACC,KAAK,CAAE,yBAAwBH,KAAK,CAACI,MAAO,gBAAe,GAC7DC,aAAI,CAACC,SAAS,CAAC,SAAS,EAAEN,KAAK,CAACI,MAAM,CAAC,CAAC;EAC1C,KAAK,MAAMG,OAAO,IAAIP,KAAK,EAAE;IAC3B,IAAI;MAEFT,WAAE,CAACiB,UAAU,CAACD,OAAO,CAAC;IACxB,CAAC,CAAC,OAAOE,CAAC,EAAE;MACVP,eAAG,CAACQ,IAAI,CAACD,CAAC,CAACE,OAAO,CAAC;IACrB;EACF;AACF,CAAC,CAAC;AAeF,eAAeC,eAAeA,CAAEC,IAAI,EAAEC,OAAO,EAAE;EAC7C,IAAI,CAACC,eAAC,CAACC,OAAO,CAACF,OAAO,CAAC,EAAE;IACvBA,OAAO,GAAG,CAACA,OAAO,CAAC;EACrB;EAEA,OAAO,MAAMrB,gBAAgB,CAACwB,OAAO,CAACJ,IAAI,EAAE,YAAY;IAItD,MAAMxB,QAAQ,GAAG,MAAME,WAAE,CAAC2B,IAAI,CAACL,IAAI,CAAC;IACpCX,eAAG,CAACC,KAAK,CAAE,eAAcU,IAAK,WAAUxB,QAAS,EAAC,CAAC;IAEnD,IAAIJ,UAAU,CAACkC,GAAG,CAAC9B,QAAQ,CAAC,EAAE;MAC5B,MAAM+B,UAAU,GAAGC,aAAI,CAACC,OAAO,CAACrC,UAAU,CAACsC,GAAG,CAAClC,QAAQ,CAAC,EAAE,GAAGyB,OAAO,CAAC;MACrE,IAAI,MAAMvB,WAAE,CAACiC,MAAM,CAACJ,UAAU,CAAC,EAAE;QAC/B,OAAOA,UAAU;MACnB;MACAnC,UAAU,CAACwC,GAAG,CAACpC,QAAQ,CAAC;IAC1B;IAEA,MAAMqC,OAAO,GAAG,MAAMC,gBAAO,CAACC,OAAO,CAAC,CAAC;IACvC1B,eAAG,CAACC,KAAK,CAAE,oCAAmCU,IAAK,SAAQa,OAAQ,GAAE,CAAC;IACtE,MAAM,IAAAG,kBAAS,EAAChB,IAAI,EAAEa,OAAO,CAAC;IAC9B,MAAMN,UAAU,GAAGC,aAAI,CAACC,OAAO,CAACI,OAAO,EAAE,GAAGZ,OAAO,CAAC;IACpD,IAAI,EAAC,MAAMvB,WAAE,CAACiC,MAAM,CAACJ,UAAU,CAAC,GAAE;MAChC,MAAM,IAAIU,KAAK,CAAE,GAAEhB,OAAO,CAACiB,IAAI,CAACV,aAAI,CAACW,GAAG,CAAE,wBAAuBnB,IAAK,YAAW,GAC9E,sDAAqD,CAAC;IAC3D;IACA5B,UAAU,CAACgD,GAAG,CAAC5C,QAAQ,EAAEqC,OAAO,CAAC;IACjC,OAAON,UAAU;EACnB,CAAC,CAAC;AACJ;AAWAxB,gBAAgB,CAACsC,cAAc,GAAG,eAAeA,cAAcA,CAAEC,IAAI,EAAEC,QAAQ,EAAE;EAC/E,MAAM,IAAI,CAACC,cAAc,CAAC,CAAC;EAC3BF,IAAI,GAAG,CACL,MAAM,EAAE,IAAI,CAACG,QAAQ,CAACC,UAAU,EAChC,GAAGJ,IAAI,CACR;EACD,MAAMK,GAAG,GAAG3C,OAAO,CAAC2C,GAAG;EACvB,IAAI,IAAI,CAACC,OAAO,EAAE;IAChBD,GAAG,CAACE,uBAAuB,GAAI,GAAE,IAAI,CAACD,OAAQ,EAAC;EACjD;EACA,IAAI,IAAI,CAACE,OAAO,EAAE;IAChBH,GAAG,CAACI,uBAAuB,GAAG,IAAI,CAACD,OAAO;EAC5C;EACAzC,eAAG,CAACC,KAAK,CAAE,wCAAuC0C,IAAI,CAACC,SAAS,CAACX,IAAI,CAAE,EAAC,CAAC;EACzE,IAAIY,MAAM;EACV,IAAI;IACF,CAAC;MAACA;IAAM,CAAC,GAAG,MAAM,IAAAC,kBAAI,EAAC,MAAM,IAAAC,qBAAY,EAAC,CAAC,EAAEd,IAAI,EAAE;MACjDK,GAAG;MACHU,OAAO,EAAEvD;IACX,CAAC,CAAC;IACFO,eAAG,CAACC,KAAK,CAAE,mBAAkBY,eAAC,CAACoC,QAAQ,CAACJ,MAAM,EAAE;MAAC3C,MAAM,EAAE;IAAG,CAAC,CAAE,EAAC,CAAC;IACjE,OAAO2C,MAAM;EACf,CAAC,CAAC,OAAOtC,CAAC,EAAE;IACV,IAAIA,CAAC,CAACsC,MAAM,EAAE;MACZ7C,eAAG,CAACC,KAAK,CAAE,mBAAkBM,CAAC,CAACsC,MAAO,EAAC,CAAC;IAC1C;IACA,IAAItC,CAAC,CAAC2C,MAAM,EAAE;MACZlD,eAAG,CAACC,KAAK,CAAE,mBAAkBM,CAAC,CAAC2C,MAAO,EAAC,CAAC;IAC1C;IACA,MAAM,IAAItB,KAAK,CAAE,GAAEM,QAAS,qBAAoB3B,CAAC,CAACE,OAAQ,EAAC,CAAC;EAC9D;AACF,CAAC;AAODf,gBAAgB,CAACyD,aAAa,GAAG,eAAeA,aAAaA,CAAEC,YAAY,EAAE;EAC3E,MAAMnB,IAAI,GAAG,CACX,iBAAiB,EACjB,OAAO,EAAE,IAAI,CAACoB,UAAU,CAAClC,IAAI,EAC7B,aAAa,EAAE,IAAI,CAACmC,WAAW,EAC/B,UAAU,EAAEF,YAAY,CACzB;EACDpD,eAAG,CAACC,KAAK,CAAE,oCAAmC,IAAI,CAACqD,WAAY,GAAE,CAAC;EAClE,MAAM,IAAI,CAACtB,cAAc,CAACC,IAAI,EAAE,iCAAiC,CAAC;EAClE,OAAOmB,YAAY;AACrB,CAAC;AAyBD1D,gBAAgB,CAAC6D,mBAAmB,GAAG,eAAeA,mBAAmBA,CAAEC,iBAAiB,EAAEC,OAAO,GAAG,CAAC,CAAC,EAAE;EAC1G,MAAMC,WAAW,GAAG,IAAAC,yBAAgB,EAAC,MAAM,IAAI,CAACC,WAAW,CAAC,CAAC,EAAEH,OAAO,CAAC;EACvE,OAAO,MAAM,IAAI,CAACI,OAAO,CAAC,CAAC,kBAAkB,EAAE,GAAGH,WAAW,EAAE,GAAGF,iBAAiB,CAAC,EAAE;IACpFR,OAAO,EAAES,OAAO,CAACT,OAAO;IACxBc,cAAc,EAAEL,OAAO,CAACK;EAC1B,CAAC,CAAC;AACJ,CAAC;AAsBDpE,gBAAgB,CAACqE,WAAW,GAAG,eAAeA,WAAWA,CAAEpD,IAAI,EAAE8C,OAAO,GAAG,CAAC,CAAC,EAAE;EAC7E,MAAM;IACJO,gBAAgB;IAChBC,iBAAiB;IACjBjB;EACF,CAAC,GAAGS,OAAO;EAEX,MAAMxB,IAAI,GAAG,CACX,cAAc,EACd,OAAO,EAAE,IAAI,CAACoB,UAAU,CAAClC,IAAI,EAC7B,QAAQ,EAAER,IAAI,EACd,kBAAkB,EAAEqC,OAAO,IAAIkB,6BAAoB,EACnD,aAAa,EAAE,IAAI,CAACZ,WAAW,CAChC;EACD,IAAIW,iBAAiB,EAAE;IACrBhC,IAAI,CAACkC,IAAI,CAAC,mBAAmB,CAAC;EAChC;EACA,MAAMC,KAAK,GAAG,CACZ,IAAI,CAACpC,cAAc,CAACC,IAAI,EAAG,mBAAkBd,aAAI,CAACkD,QAAQ,CAAC1D,IAAI,CAAE,mBAAkB,IAAI,CAAC2C,WAAY,EAAC,CAAC,CACvG;EACD,IAAIU,gBAAgB,EAAE;IACpBI,KAAK,CAACD,IAAI,CAAC,IAAI,CAACG,UAAU,CAAC3D,IAAI,CAAC,CAAC;EACnC;EACA,MAAM,GAAG4D,OAAO,CAAC,GAAG,MAAMC,iBAAC,CAACC,GAAG,CAACL,KAAK,CAAC;EACtC,IAAIJ,gBAAgB,IAAIO,OAAO,EAAE;IAE/B,MAAM,IAAI,CAACG,mBAAmB,CAACH,OAAO,CAACI,IAAI,CAAC;EAC9C;AACF,CAAC;AASDjF,gBAAgB,CAACkF,cAAc,GAAG,eAAeA,cAAcA,CAAEjE,IAAI,EAAE;EACrE,OAAO,MAAMD,eAAe,CAACC,IAAI,EAAE,CAAC,QAAQ,EAAE/B,QAAQ,CAAC,CAAC;AAC1D,CAAC;AAaDc,gBAAgB,CAACmF,kBAAkB,GAAG,eAAeA,kBAAkBA,CAAElE,IAAI,EAAEmE,QAAQ,GAAG,IAAI,EAAE;EAC9F,IAAIA,QAAQ,EAAE;IACZ,IAAI;MACF,OAAO,MAAMpE,eAAe,CAACC,IAAI,EAAE,CAAC,QAAQ,EAAE9B,YAAY,CAACiG,QAAQ,CAAC,CAAC,CAAC;IACxE,CAAC,CAAC,OAAOvE,CAAC,EAAE;MACVP,eAAG,CAACC,KAAK,CAACM,CAAC,CAACE,OAAO,CAAC;MACpBT,eAAG,CAAC+E,IAAI,CAAE,+DAA8DpE,IAAK,WAAU,GACpF,oCAAmC,CAAC;MACvC,OAAO,MAAM,IAAI,CAACiE,cAAc,CAACjE,IAAI,CAAC;IACxC;EACF;EAEA,MAAMqE,gBAAgB,GAAG,CAAC,IAAI,EAAE,OAAO,CAAC;EACxC,KAAK,MAAMlG,IAAI,IAAIkG,gBAAgB,EAAE;IACnC,IAAI;MACF,OAAO,MAAMtE,eAAe,CAACC,IAAI,EAAE,CAAC,QAAQ,EAAE9B,YAAY,CAACC,IAAI,CAAC,CAAC,CAAC;IACpE,CAAC,CAAC,OAAOmG,GAAG,EAAE,CAAC;EACjB;EAEAjF,eAAG,CAAC+E,IAAI,CAAE,uDAAsDpC,IAAI,CAACC,SAAS,CAACoC,gBAAgB,CAAE,IAAG,GACjG,iCAAgC,CAAC;EACpC,OAAO,MAAM,IAAI,CAACJ,cAAc,CAACjE,IAAI,CAAC;AACxC,CAAC;AAEDjB,gBAAgB,CAACwF,sBAAsB,GAAG,SAASA,sBAAsBA,CAAEC,MAAM,EAAE;EACjF,OAAO,8BAA8B,CAACC,IAAI,CAACD,MAAM,CAAC;AACpD,CAAC;AAAC,IAAAE,QAAA,GAEa3F,gBAAgB;AAAA4F,OAAA,CAAAC,OAAA,GAAAF,QAAA"}