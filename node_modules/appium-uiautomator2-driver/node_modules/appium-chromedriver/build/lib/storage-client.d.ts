export default ChromedriverStorageClient;
export type SyncOptions = import('./types').SyncOptions;
export type OSInfo = import('./types').OSInfo;
export type ChromedriverDetails = import('./types').ChromedriverDetails;
export type ChromedriverDetailsMapping = import('./types').ChromedriverDetailsMapping;
declare class ChromedriverStorageClient {
    /**
     *
     * @param {import('./types').ChromedriverStorageClientOpts} args
     */
    constructor(args?: import('./types').ChromedriverStorageClientOpts);
    chromedriverDir: string;
    timeout: number;
    /** @type {ChromedriverDetailsMapping} */
    mapping: ChromedriverDetailsMapping;
    /**
     * @typedef {Object} AdditionalDriverDetails
     * @property {string?} version - Chromedriver version
     * or `null` if it cannot be found
     * @property {string?} minBrowserVersion - The minimum browser version
     * supported by chromedriver or `null` if it cannot be found
     */
    /**
     * Gets additional chromedriver details from chromedriver
     * release notes
     *
     * @param {string} content - Release notes of the corresponding chromedriver
     * @returns {AdditionalDriverDetails}
     */
    parseNotes(content: string): {
        /**
         * - Chromedriver version
         * or `null` if it cannot be found
         */
        version: string | null;
        /**
         * - The minimum browser version
         * supported by chromedriver or `null` if it cannot be found
         */
        minBrowserVersion: string | null;
    };
    /**
     * Downloads chromedriver release notes and puts them
     * into the dictionary argument
     *
     * The method call mutates by merging `AdditionalDriverDetails`
     * @param {string} driverKey - Driver version plus archive name
     * @param {string} notesUrl - The URL of chromedriver notes
     * @param {ChromedriverDetails} infoDict - The dictionary containing driver info.
     * @throws {Error} if the release notes cannot be downloaded
     */
    retrieveAdditionalDriverInfo(driverKey: string, notesUrl: string, infoDict: ChromedriverDetails): Promise<void>;
    /**
     * Parses chromedriver storage XML and stores
     * the parsed results into `this.mapping`
     *
     * @param {Document} doc - The DOM representation
     * of the chromedriver storage XML
     * @param {boolean} shouldParseNotes [true] - If set to `true`
     * then additional drivers information is going to be parsed
     * and assigned to `this.mapping`
     */
    parseStorageXml(doc: Document, shouldParseNotes?: boolean): Promise<void>;
    /**
     * Retrieves chromedriver mapping from the storage
     *
     * @param {boolean} shouldParseNotes [true] - if set to `true`
     * then additional chromedrivers info is going to be retrieved and
     * parsed from release notes
     * @returns {Promise<ChromedriverDetailsMapping>}
     */
    retrieveMapping(shouldParseNotes?: boolean): Promise<ChromedriverDetailsMapping>;
    /**
     * Extracts downloaded chromedriver archive
     * into the given destination
     *
     * @param {string} src - The source archive path
     * @param {string} dst - The destination chromedriver path
     */
    unzipDriver(src: string, dst: string): Promise<void>;
    /**
     * Filters `this.mapping` to only select matching
     * chromedriver entries by operating system information
     * and/or additional synchronization options (if provided)
     *
     * @param {OSInfo} osInfo
     * @param {SyncOptions} opts
     * @returns {Array<String>} The list of filtered chromedriver
     * entry names (version/archive name)
     */
    selectMatchingDrivers(osInfo: OSInfo, opts?: SyncOptions): Array<string>;
    /**
     * Retrieves the given chromedriver from the storage
     * and unpacks it into `this.chromedriverDir` folder
     *
     * @param {number} index - The unique driver index
     * @param {string} driverKey - The driver key in `this.mapping`
     * @param {string} archivesRoot - The temporary folder path to extract
     * downloaded archives to
     * @param {boolean} isStrict [true] - Whether to throw an error (`true`)
     * or return a boolean result if the driver retrieval process fails
     * @throws {Error} if there was a failure while retrieving the driver
     * and `isStrict` is set to `true`
     * @returns {Promise<boolean>} if `true` then the chromedriver is successfully
     * downloaded and extracted.
     */
    retrieveDriver(index: number, driverKey: string, archivesRoot: string, isStrict?: boolean): Promise<boolean>;
    /**
     * Retrieves chromedrivers from the remote storage
     * to the local file system
     *
     * @param {SyncOptions} opts
     * @throws {Error} if there was a problem while retrieving
     * the drivers
     * @returns {Promise<string[]>} The list of successfully synchronized driver keys
     */
    syncDrivers(opts?: SyncOptions): Promise<string[]>;
}
//# sourceMappingURL=storage-client.d.ts.map