/// <reference types="node" />
export default Chromedriver;
export type ChromedriverVersionMapping = import('./types').ChromedriverVersionMapping;
export class Chromedriver extends events {
    /**
     *
     * @param {import('./types').ChromedriverOpts} args
     */
    constructor(args?: import('./types').ChromedriverOpts);
    _log: import("@appium/types").AppiumLogger;
    proxyHost: string;
    proxyPort: string | number;
    adb: import("./types").AdbStub | undefined;
    cmdArgs: string[] | undefined;
    proc: SubProcess | null;
    useSystemExecutable: boolean;
    chromedriver: string | undefined;
    executableDir: string;
    mappingPath: string | undefined;
    bundleId: string | undefined;
    executableVerified: boolean;
    state: string;
    jwproxy: JWProxy;
    verbose: boolean | undefined;
    logPath: string | undefined;
    disableBuildCheck: boolean;
    storageClient: ChromedriverStorageClient | null;
    details: {
        info?: {
            Browser: string;
        } | undefined;
    } | undefined;
    /** @type {any} */
    capabilities: any;
    desiredProtocol: string;
    driverVersion: string | null;
    get log(): import("@appium/types").AppiumLogger;
    getDriversMapping(): Promise<any>;
    /**
     * @param {ChromedriverVersionMapping} mapping
     */
    getChromedrivers(mapping: ChromedriverVersionMapping): Promise<any[]>;
    getChromeVersion(): Promise<semver.SemVer | null>;
    /**
     *
     * @param {ChromedriverVersionMapping} newMapping
     * @returns {Promise<void>}
     */
    updateDriversMapping(newMapping: ChromedriverVersionMapping): Promise<void>;
    /**
     * @returns {Promise<string>}
     */
    getCompatibleChromedriver(): Promise<string>;
    initChromedriverPath(): Promise<string>;
    /**
     * Sync the WebDriver protocol if current on going protocol is W3C or MJSONWP.
     * Does nothing if this.driverVersion was null.
     */
    syncProtocol(): void;
    /**
     * Sync the protocol by reading the given output
     *
     * @param {string} out The output of WebDriver process start
     */
    detectWebDriverProtocol(out: string): void;
    /**
     *
     * @param {object} caps
     * @param {boolean} emitStartingState
     */
    start(caps: object, emitStartingState?: boolean): Promise<void>;
    sessionId(): string | null;
    restart(): Promise<void>;
    waitForOnline(): Promise<void>;
    getStatus(): Promise<any>;
    startSession(): Promise<void>;
    stop(emitStates?: boolean): Promise<void>;
    /**
     *
     * @param {string} state
     */
    changeState(state: string): void;
    /**
     *
     * @param {string} url
     * @param {'POST'|'GET'|'DELETE'} method
     * @param {any} body
     * @returns
     */
    sendCommand(url: string, method: 'POST' | 'GET' | 'DELETE', body: any): Promise<any>;
    /**
     *
     * @param {any} req
     * @param {any} res
     * @privateRemarks req / res probably from Express
     */
    proxyReq(req: any, res: any): Promise<void>;
    killAll(): Promise<void>;
    hasWorkingWebview(): Promise<boolean>;
}
export namespace Chromedriver {
    const EVENT_ERROR: string;
    const EVENT_CHANGED: string;
    const STATE_STOPPED: string;
    const STATE_STARTING: string;
    const STATE_ONLINE: string;
    const STATE_STOPPING: string;
    const STATE_RESTARTING: string;
}
import events from 'events';
import { SubProcess } from 'teen_process';
import { JWProxy } from '@appium/base-driver';
import ChromedriverStorageClient from './storage-client';
import semver from 'semver';
//# sourceMappingURL=chromedriver.d.ts.map