"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("./utils");
const lodash_1 = __importDefault(require("lodash"));
const xpath_1 = __importDefault(require("xpath"));
const xmldom_1 = require("@xmldom/xmldom");
const bluebird_1 = __importDefault(require("bluebird"));
const path_1 = __importDefault(require("path"));
const os_1 = __importDefault(require("os"));
const support_1 = require("@appium/support");
const TIMEOUT_MS = 15000;
const MAX_PARALLEL_DOWNLOADS = 5;
const log = support_1.logger.getLogger('ChromedriverStorageClient');
/**
 *
 * @param {string} src
 * @param {string} checksum
 * @returns {Promise<boolean>}
 */
async function isCrcOk(src, checksum) {
    const md5 = await support_1.fs.hash(src, 'md5');
    return lodash_1.default.toLower(md5) === lodash_1.default.toLower(checksum);
}
/**
 *
 * @param {Node|Attr} parent
 * @param {string?} childName
 * @param {string?} text
 * @returns
 */
function findChildNode(parent, childName = null, text = null) {
    if (!childName && !text) {
        return null;
    }
    if (!parent.hasChildNodes()) {
        return null;
    }
    for (let childNodeIdx = 0; childNodeIdx < parent.childNodes.length; childNodeIdx++) {
        const childNode = /** @type {Element|Attr} */ (parent.childNodes[childNodeIdx]);
        if (childName && !text && childName === childNode.localName) {
            return childNode;
        }
        if (text) {
            const childText = extractNodeText(childNode);
            if (!childText) {
                continue;
            }
            if (childName && childName === childNode.localName && text === childText) {
                return childNode;
            }
            if (!childName && text === childText) {
                return childNode;
            }
        }
    }
    return null;
}
/**
 *
 * @param {Node?} node
 * @returns
 */
function extractNodeText(node) {
    return !node || !node.firstChild || !support_1.util.hasValue(node.firstChild.nodeValue)
        ? null
        : node.firstChild.nodeValue;
}
class ChromedriverStorageClient {
    /**
     *
     * @param {import('./types').ChromedriverStorageClientOpts} args
     */
    constructor(args = {}) {
        const { chromedriverDir = (0, utils_1.getChromedriverDir)(), timeout = TIMEOUT_MS } = args;
        this.chromedriverDir = chromedriverDir;
        this.timeout = timeout;
        /** @type {ChromedriverDetailsMapping} */
        this.mapping = {};
    }
    /**
     * @typedef {Object} AdditionalDriverDetails
     * @property {string?} version - Chromedriver version
     * or `null` if it cannot be found
     * @property {string?} minBrowserVersion - The minimum browser version
     * supported by chromedriver or `null` if it cannot be found
     */
    /**
     * Gets additional chromedriver details from chromedriver
     * release notes
     *
     * @param {string} content - Release notes of the corresponding chromedriver
     * @returns {AdditionalDriverDetails}
     */
    parseNotes(content) {
        const result = {};
        const versionMatch = /^\s*[-]+ChromeDriver[\D]+([\d.]+)/im.exec(content);
        if (versionMatch) {
            result.version = versionMatch[1];
        }
        const minBrowserVersionMatch = /^\s*Supports Chrome[\D]+(\d+)/im.exec(content);
        if (minBrowserVersionMatch) {
            result.minBrowserVersion = minBrowserVersionMatch[1];
        }
        return result;
    }
    /**
     * Downloads chromedriver release notes and puts them
     * into the dictionary argument
     *
     * The method call mutates by merging `AdditionalDriverDetails`
     * @param {string} driverKey - Driver version plus archive name
     * @param {string} notesUrl - The URL of chromedriver notes
     * @param {ChromedriverDetails} infoDict - The dictionary containing driver info.
     * @throws {Error} if the release notes cannot be downloaded
     */
    async retrieveAdditionalDriverInfo(driverKey, notesUrl, infoDict) {
        const notes = await (0, utils_1.retrieveData)(notesUrl, {
            'user-agent': 'appium',
            accept: '*/*',
        }, { timeout: this.timeout });
        const { minBrowserVersion } = this.parseNotes(notes);
        if (!minBrowserVersion) {
            log.debug(`The driver '${driverKey}' does not contain valid release notes at ${notesUrl}. ` +
                `Skipping it`);
            return;
        }
        infoDict.minBrowserVersion = minBrowserVersion;
    }
    /**
     * Parses chromedriver storage XML and stores
     * the parsed results into `this.mapping`
     *
     * @param {Document} doc - The DOM representation
     * of the chromedriver storage XML
     * @param {boolean} shouldParseNotes [true] - If set to `true`
     * then additional drivers information is going to be parsed
     * and assigned to `this.mapping`
     */
    async parseStorageXml(doc, shouldParseNotes = true) {
        const driverNodes = /** @type {Array<Node|Attr>} */ (xpath_1.default.select(`//*[local-name(.)='Contents']`, doc));
        log.debug(`Parsed ${driverNodes.length} entries from storage XML`);
        if (lodash_1.default.isEmpty(driverNodes)) {
            return;
        }
        const promises = [];
        for (const driverNode of driverNodes) {
            const k = extractNodeText(findChildNode(driverNode, 'Key'));
            if (!lodash_1.default.includes(k, '/chromedriver_')) {
                continue;
            }
            const key = String(k);
            const etag = extractNodeText(findChildNode(driverNode, 'ETag'));
            if (!etag) {
                log.debug(`The entry '${key}' does not contain the checksum. Skipping it`);
                continue;
            }
            /** @type {ChromedriverDetails} */
            const cdInfo = {
                url: `${utils_1.CD_CDN}/${key}`,
                etag: lodash_1.default.trim(etag, '"'),
                version: /** @type {string} */ (lodash_1.default.first(key.split('/'))),
                minBrowserVersion: null,
            };
            this.mapping[key] = cdInfo;
            const notesPath = `${cdInfo.version}/notes.txt`;
            const isNotesPresent = !!driverNodes.reduce((acc, node) => Boolean(acc || findChildNode(node, 'Key', notesPath)), false);
            if (!isNotesPresent) {
                cdInfo.minBrowserVersion = null;
                if (shouldParseNotes) {
                    log.info(`The entry '${key}' does not contain any notes. Skipping it`);
                }
                continue;
            }
            else if (!shouldParseNotes) {
                continue;
            }
            promises.push(this.retrieveAdditionalDriverInfo(key, `${utils_1.CD_CDN}/${notesPath}`, cdInfo));
            if (promises.length % MAX_PARALLEL_DOWNLOADS === 0) {
                await bluebird_1.default.all(promises);
            }
        }
        await bluebird_1.default.all(promises);
        log.info(`The total count of entries in the mapping: ${lodash_1.default.size(this.mapping)}`);
    }
    /**
     * Retrieves chromedriver mapping from the storage
     *
     * @param {boolean} shouldParseNotes [true] - if set to `true`
     * then additional chromedrivers info is going to be retrieved and
     * parsed from release notes
     * @returns {Promise<ChromedriverDetailsMapping>}
     */
    async retrieveMapping(shouldParseNotes = true) {
        const xml = await (0, utils_1.retrieveData)(utils_1.CD_CDN, {
            'user-agent': 'appium',
            accept: 'application/xml, */*',
        }, { timeout: this.timeout });
        const doc = new xmldom_1.DOMParser().parseFromString(xml);
        await this.parseStorageXml(doc, shouldParseNotes);
        return lodash_1.default.cloneDeep(this.mapping);
    }
    /**
     * Extracts downloaded chromedriver archive
     * into the given destination
     *
     * @param {string} src - The source archive path
     * @param {string} dst - The destination chromedriver path
     */
    async unzipDriver(src, dst) {
        const tmpRoot = await support_1.tempDir.openDir();
        try {
            await support_1.zip.extractAllTo(src, tmpRoot);
            const chromedriverPath = await support_1.fs.walkDir(tmpRoot, true, (itemPath, isDirectory) => !isDirectory && lodash_1.default.toLower(path_1.default.parse(itemPath).name) === 'chromedriver');
            if (!chromedriverPath) {
                throw new Error('The archive was unzipped properly, but we could not find any chromedriver executable');
            }
            log.debug(`Moving the extracted '${path_1.default.basename(chromedriverPath)}' to '${dst}'`);
            await support_1.fs.mv(chromedriverPath, dst, {
                mkdirp: true,
            });
        }
        finally {
            await support_1.fs.rimraf(tmpRoot);
        }
    }
    /**
     * Filters `this.mapping` to only select matching
     * chromedriver entries by operating system information
     * and/or additional synchronization options (if provided)
     *
     * @param {OSInfo} osInfo
     * @param {SyncOptions} opts
     * @returns {Array<String>} The list of filtered chromedriver
     * entry names (version/archive name)
     */
    selectMatchingDrivers(osInfo, opts = {}) {
        const { minBrowserVersion, versions = [] } = opts;
        let driversToSync = lodash_1.default.keys(this.mapping);
        if (!lodash_1.default.isEmpty(versions)) {
            // Handle only selected versions if requested
            log.debug(`Selecting chromedrivers whose versions match to ${versions}`);
            driversToSync = driversToSync.filter((cdName) => versions.includes(`${this.mapping[cdName].version}`));
            log.debug(`Got ${support_1.util.pluralize('item', driversToSync.length, true)}`);
            if (lodash_1.default.isEmpty(driversToSync)) {
                return [];
            }
        }
        const minBrowserVersionInt = (0, utils_1.convertToInt)(minBrowserVersion);
        if (minBrowserVersionInt !== null) {
            // Only select drivers that support the current browser whose major version number equals to `minBrowserVersion`
            log.debug(`Selecting chromedrivers whose minimum supported browser version matches to ${minBrowserVersionInt}`);
            let closestMatchedVersionNumber = 0;
            // Select the newest available and compatible chromedriver
            for (const cdName of driversToSync) {
                const currentMinBrowserVersion = parseInt(String(this.mapping[cdName].minBrowserVersion), 10);
                if (!Number.isNaN(currentMinBrowserVersion) &&
                    currentMinBrowserVersion <= minBrowserVersionInt &&
                    closestMatchedVersionNumber < currentMinBrowserVersion) {
                    closestMatchedVersionNumber = currentMinBrowserVersion;
                }
            }
            driversToSync = driversToSync.filter((cdName) => `${this.mapping[cdName].minBrowserVersion}` ===
                `${closestMatchedVersionNumber > 0 ? closestMatchedVersionNumber : minBrowserVersionInt}`);
            log.debug(`Got ${support_1.util.pluralize('item', driversToSync.length, true)}`);
            if (lodash_1.default.isEmpty(driversToSync)) {
                return [];
            }
            log.debug(`Will select candidate ${support_1.util.pluralize('driver', driversToSync.length)} ` +
                `versioned as '${lodash_1.default.uniq(driversToSync.map((cdName) => this.mapping[cdName].version))}'`);
        }
        if (!lodash_1.default.isEmpty(osInfo)) {
            // Filter out drivers for unsupported system architectures
            let { name, arch } = osInfo;
            if (arch === utils_1.X64 && !driversToSync.some((cdName) => cdName.includes(`_${name}${utils_1.X64}`))) {
                // Fall back to x86 build if x64 one is not available for the given OS
                arch = utils_1.X86;
            }
            // https://stackoverflow.com/questions/65146751/detecting-apple-silicon-mac-in-javascript
            if (name === utils_1.OS.mac && lodash_1.default.includes(lodash_1.default.toLower(os_1.default.cpus()[0].model), 'apple')) {
                for (const armSuffix of utils_1.APPLE_ARM_SUFFIXES) {
                    if (driversToSync.some((cdName) => cdName.includes(armSuffix))) {
                        // prefer executable for ARM arch if present
                        arch = armSuffix;
                        break;
                    }
                }
            }
            log.debug(`Selecting chromedrivers whose platform matches to ${name}${arch}`);
            const platformRe = new RegExp(`(\\b|_)${name}${arch}\\b`);
            driversToSync = driversToSync.filter((cdName) => platformRe.test(cdName));
            log.debug(`Got ${support_1.util.pluralize('item', driversToSync.length, true)}`);
        }
        return driversToSync;
    }
    /**
     * Retrieves the given chromedriver from the storage
     * and unpacks it into `this.chromedriverDir` folder
     *
     * @param {number} index - The unique driver index
     * @param {string} driverKey - The driver key in `this.mapping`
     * @param {string} archivesRoot - The temporary folder path to extract
     * downloaded archives to
     * @param {boolean} isStrict [true] - Whether to throw an error (`true`)
     * or return a boolean result if the driver retrieval process fails
     * @throws {Error} if there was a failure while retrieving the driver
     * and `isStrict` is set to `true`
     * @returns {Promise<boolean>} if `true` then the chromedriver is successfully
     * downloaded and extracted.
     */
    async retrieveDriver(index, driverKey, archivesRoot, isStrict = false) {
        const { url, etag, version } = this.mapping[driverKey];
        const archivePath = path_1.default.resolve(archivesRoot, `${index}.zip`);
        log.debug(`Retrieving '${url}' to '${archivePath}'`);
        try {
            await support_1.net.downloadFile(url, archivePath, {
                isMetered: false,
                timeout: TIMEOUT_MS,
            });
        }
        catch (e) {
            const err = /** @type {Error} */ (e);
            const msg = `Cannot download chromedriver archive. Original error: ${err.message}`;
            if (isStrict) {
                throw new Error(msg);
            }
            log.error(msg);
            return false;
        }
        if (!(await isCrcOk(archivePath, etag))) {
            const msg = `The checksum for the downloaded chromedriver '${driverKey}' did not match`;
            if (isStrict) {
                throw new Error(msg);
            }
            log.error(msg);
            return false;
        }
        const fileName = `${path_1.default.parse(url).name}_v${version}` + (support_1.system.isWindows() ? '.exe' : '');
        const targetPath = path_1.default.resolve(this.chromedriverDir, fileName);
        try {
            await this.unzipDriver(archivePath, targetPath);
            await support_1.fs.chmod(targetPath, 0o755);
            log.debug(`Permissions of the file '${targetPath}' have been changed to 755`);
        }
        catch (e) {
            const err = /** @type {Error} */ (e);
            if (isStrict) {
                throw err;
            }
            log.error(err.message);
            return false;
        }
        return true;
    }
    /**
     * Retrieves chromedrivers from the remote storage
     * to the local file system
     *
     * @param {SyncOptions} opts
     * @throws {Error} if there was a problem while retrieving
     * the drivers
     * @returns {Promise<string[]>} The list of successfully synchronized driver keys
     */
    async syncDrivers(opts = {}) {
        if (lodash_1.default.isEmpty(this.mapping)) {
            await this.retrieveMapping(!!opts.minBrowserVersion);
        }
        if (lodash_1.default.isEmpty(this.mapping)) {
            throw new Error('Cannot retrieve chromedrivers mapping from Google storage');
        }
        const driversToSync = this.selectMatchingDrivers(opts.osInfo ?? (await (0, utils_1.getOsInfo)()), opts);
        if (lodash_1.default.isEmpty(driversToSync)) {
            log.debug(`There are no drivers to sync. Exiting`);
            return [];
        }
        log.debug(`Got ${support_1.util.pluralize('driver', driversToSync.length, true)} to sync: ` +
            JSON.stringify(driversToSync, null, 2));
        /**
         * @type {string[]}
         */
        const synchronizedDrivers = [];
        const promises = [];
        const archivesRoot = await support_1.tempDir.openDir();
        try {
            for (const [idx, driverKey] of driversToSync.entries()) {
                promises.push((async () => {
                    if (await this.retrieveDriver(idx, driverKey, archivesRoot, !lodash_1.default.isEmpty(opts))) {
                        synchronizedDrivers.push(driverKey);
                    }
                })());
                if (promises.length % MAX_PARALLEL_DOWNLOADS === 0) {
                    await bluebird_1.default.all(promises);
                }
            }
            await bluebird_1.default.all(promises);
        }
        finally {
            await support_1.fs.rimraf(archivesRoot);
        }
        if (!lodash_1.default.isEmpty(synchronizedDrivers)) {
            log.info(`Successfully synchronized ` +
                `${support_1.util.pluralize('chromedriver', synchronizedDrivers.length, true)}`);
        }
        else {
            log.info(`No chromedrivers were synchronized`);
        }
        return synchronizedDrivers;
    }
}
exports.default = ChromedriverStorageClient;
/**
 * @typedef {import('./types').SyncOptions} SyncOptions
 * @typedef {import('./types').OSInfo} OSInfo
 * @typedef {import('./types').ChromedriverDetails} ChromedriverDetails
 * @typedef {import('./types').ChromedriverDetailsMapping} ChromedriverDetailsMapping
 */
//# sourceMappingURL=storage-client.js.map