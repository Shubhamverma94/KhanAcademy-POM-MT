{"version":3,"file":"media-projection.js","names":["_lodash","_interopRequireDefault","require","_asyncbox","_support","_path","_bluebird","_androidHelpers","_moment","commands","exports","DEFAULT_EXT","RECORDING_STARTUP_TIMEOUT_MS","RECORDING_STOP_TIMEOUT_MS","MIN_API_LEVEL","RECORDING_SERVICE_NAME","SETTINGS_HELPER_PKG_ID","RECORDING_ACTIVITY_NAME","RECORDING_ACTION_START","RECORDING_ACTION_STOP","RECORDINGS_ROOT","DEFAULT_FILENAME_FORMAT","uploadRecordedMedia","localFile","remotePath","uploadOptions","_","isEmpty","util","toInMemoryBase64","toString","user","pass","method","headers","fileFieldName","formFields","uploadTimeout","timeout","options","auth","net","uploadFile","adjustMediaExtension","name","toLower","endsWith","verifyMediaProjectionRecordingIsSupported","adb","apiLevel","getApiLevel","Error","MediaProjectionRecorder","constructor","isRunning","stdout","shell","includes","start","opts","cleanup","filename","maxDurationSec","priority","resolution","args","push","B","resolve","reject","setTimeout","pullRecent","recordings","ls","dstPath","path","join","tempDir","openDir","pull","stop","waitForCondition","waitMs","intervalMs","e","mobileStartMediaProjectionRecording","recorder","fname","moment","format","didStart","log","info","mobileIsMediaProjectionRecordingRunning","mobileStopMediaProjectionRecording","recentRecordingPath","size","fs","stat","debug","toReadableSizeString","rimraf","dirname","_default","default"],"sources":["../../../lib/commands/media-projection.js"],"sourcesContent":["import _ from 'lodash';\nimport { waitForCondition } from 'asyncbox';\nimport { util, fs, net, tempDir } from '@appium/support';\nimport path from 'path';\nimport B from 'bluebird';\nimport { SETTINGS_HELPER_PKG_ID } from '../android-helpers';\nimport moment from 'moment';\n\n\nconst commands = {};\n\n// https://github.com/appium/io.appium.settings#internal-audio--video-recording\nconst DEFAULT_EXT = '.mp4';\nconst RECORDING_STARTUP_TIMEOUT_MS = 3 * 1000;\nconst RECORDING_STOP_TIMEOUT_MS = 3 * 1000;\nconst MIN_API_LEVEL = 29;\nconst RECORDING_SERVICE_NAME = `${SETTINGS_HELPER_PKG_ID}/.recorder.RecorderService`;\nconst RECORDING_ACTIVITY_NAME = `${SETTINGS_HELPER_PKG_ID}/io.appium.settings.Settings`;\nconst RECORDING_ACTION_START = `${SETTINGS_HELPER_PKG_ID}.recording.ACTION_START`;\nconst RECORDING_ACTION_STOP = `${SETTINGS_HELPER_PKG_ID}.recording.ACTION_STOP`;\nconst RECORDINGS_ROOT = `/storage/emulated/0/Android/data/${SETTINGS_HELPER_PKG_ID}/files`;\nconst DEFAULT_FILENAME_FORMAT = 'YYYY-MM-DDTHH-mm-ss';\n\n\nasync function uploadRecordedMedia (localFile, remotePath = null, uploadOptions = {}) {\n  if (_.isEmpty(remotePath)) {\n    return (await util.toInMemoryBase64(localFile)).toString();\n  }\n\n  const {\n    user,\n    pass,\n    method,\n    headers,\n    fileFieldName,\n    formFields,\n    uploadTimeout: timeout,\n  } = uploadOptions;\n  const options = {\n    method: method || 'PUT',\n    headers,\n    fileFieldName,\n    formFields,\n    timeout,\n  };\n  if (user && pass) {\n    options.auth = {user, pass};\n  }\n  await net.uploadFile(localFile, remotePath, options);\n  return '';\n}\n\nfunction adjustMediaExtension (name) {\n  return _.toLower(name).endsWith(DEFAULT_EXT) ? name : `${name}${DEFAULT_EXT}`;\n}\n\nasync function verifyMediaProjectionRecordingIsSupported (adb) {\n  const apiLevel = await adb.getApiLevel();\n  if (apiLevel < MIN_API_LEVEL) {\n    throw new Error(`Media projection-based recording is not available on API Level ${apiLevel}. ` +\n      `Minimum required API Level is ${MIN_API_LEVEL}.`);\n  }\n}\n\n\nclass MediaProjectionRecorder {\n  constructor (adb) {\n    this.adb = adb;\n  }\n\n  async isRunning () {\n    const stdout = await this.adb.shell([\n      'dumpsys', 'activity', 'services', RECORDING_SERVICE_NAME\n    ]);\n    return stdout.includes(RECORDING_SERVICE_NAME);\n  }\n\n  async start (opts = {}) {\n    if (await this.isRunning()) {\n      return false;\n    }\n\n    await this.cleanup();\n    const {\n      filename,\n      maxDurationSec,\n      priority,\n      resolution,\n    } = opts;\n    const args = [\n      'am', 'start',\n      '-n', RECORDING_ACTIVITY_NAME,\n      '-a', RECORDING_ACTION_START,\n    ];\n    if (filename) {\n      args.push('--es', 'filename', filename);\n    }\n    if (maxDurationSec) {\n      args.push('--es', 'max_duration_sec', `${maxDurationSec}`);\n    }\n    if (priority) {\n      args.push('--es', 'priority', priority);\n    }\n    if (resolution) {\n      args.push('--es', 'resolution', resolution);\n    }\n    await this.adb.shell(args);\n    await new B((resolve, reject) => {\n      setTimeout(async () => {\n        if (!await this.isRunning()) {\n          return reject(new Error(\n            `The media projection recording is not running after ${RECORDING_STARTUP_TIMEOUT_MS}ms. ` +\n            `Please check the logcat output for more details.`\n          ));\n        }\n        resolve();\n      }, RECORDING_STARTUP_TIMEOUT_MS);\n    });\n    return true;\n  }\n\n  async cleanup () {\n    await this.adb.shell([`rm -f ${RECORDINGS_ROOT}/*`]);\n  }\n\n  async pullRecent () {\n    const recordings = await this.adb.ls(RECORDINGS_ROOT, ['-tr']);\n    if (_.isEmpty(recordings)) {\n      return null;\n    }\n\n    const dstPath = path.join(await tempDir.openDir(), recordings[0]);\n    // increase timeout to 5 minutes because it might take a while to pull a large video file\n    await this.adb.pull(`${RECORDINGS_ROOT}/${recordings[0]}`, dstPath, {timeout: 300000});\n    return dstPath;\n  }\n\n  async stop () {\n    if (!await this.isRunning()) {\n      return false;\n    }\n\n    await this.adb.shell([\n      'am', 'start',\n      '-n', RECORDING_ACTIVITY_NAME,\n      '-a', RECORDING_ACTION_STOP,\n    ]);\n    try {\n      await waitForCondition(async () => !(await this.isRunning()), {\n        waitMs: RECORDING_STOP_TIMEOUT_MS,\n        intervalMs: 500,\n      });\n    } catch (e) {\n      throw new Error(\n        `The attempt to stop the current media projection recording timed out after ` +\n        `${RECORDING_STOP_TIMEOUT_MS}ms`\n      );\n    }\n    return true;\n  }\n}\n\n\n/**\n * @typedef {Object} StartRecordingOptions\n *\n * @property {string?} resolution Maximum supported resolution on-device (Detected\n * automatically by the app itself), which usually equals to Full HD 1920x1080 on most\n * phones however you can change it to following supported resolutions\n * as well: \"1920x1080\", \"1280x720\", \"720x480\", \"320x240\", \"176x144\".\n * @property {number?} maxDurationSec [900] Default value: 900 seconds which means\n * maximum allowed duration is 15 minute, you can increase it if your test takes\n * longer than that.\n * @property {string?} priority [high] Means recording thread priority is maximum\n * however if you face performance drops during testing with recording enabled, you\n * can reduce recording priority to \"normal\" or \"low\".\n * @property {string?} filename You can type recording video file name as you want,\n * but recording currently supports only \"mp4\" format so your filename must end with \".mp4\".\n * An invalid file name will fail to start the recording.\n * If not provided then the current timestamp will be used as file name.\n */\n\n/**\n * Record the display of a real devices running Android 10 (API level 29) and higher.\n * The screen activity is recorded to a MPEG-4 file. Audio is also recorded by default\n * (only for apps that allow it in their manifests).\n * If another recording has been already started then the command will exit silently.\n * The previously recorded video file is deleted when a new recording session is started.\n * Recording continues it is stopped explicitly or until the timeout happens.\n *\n * @param {?StartRecordingOptions} options Available options.\n * @returns {boolean} True if a new recording has successfully started.\n * @throws {Error} If recording has failed to start or is not supported on the device under test.\n */\ncommands.mobileStartMediaProjectionRecording = async function mobileStartMediaProjectionRecording (options = {}) {\n  await verifyMediaProjectionRecordingIsSupported(this.adb);\n\n  const {resolution, priority, maxDurationSec, filename} = options;\n  const recorder = new MediaProjectionRecorder(this.adb);\n  const fname = adjustMediaExtension(filename || moment().format(DEFAULT_FILENAME_FORMAT));\n  const didStart = await recorder.start({\n    resolution,\n    priority,\n    maxDurationSec,\n    filename: fname,\n  });\n  if (didStart) {\n    this.log.info(`A new media projection recording '${fname}' has been successfully started`);\n  } else {\n    this.log.info('Another media projection recording is already in progress. There is nothing to start');\n  }\n  return didStart;\n};\n\n/**\n * Checks if a media projection-based recording is currently running.\n *\n * @returns {boolean} True if a recording is in progress.\n * @throws {Error} If a recording is not supported on the device under test.\n */\ncommands.mobileIsMediaProjectionRecordingRunning = async function mobileIsMediaProjectionRecordingRunning () {\n  await verifyMediaProjectionRecordingIsSupported(this.adb);\n\n  const recorder = new MediaProjectionRecorder(this.adb);\n  return await recorder.isRunning();\n};\n\n/**\n * @typedef {Object} StopRecordingOptions\n *\n * @property {string?} remotePath The path to the remote location, where the resulting video should be uploaded.\n * The following protocols are supported: http/https, ftp.\n * Null or empty string value (the default setting) means the content of resulting\n * file should be encoded as Base64 and passed as the endpoont response value.\n * An exception will be thrown if the generated media file is too big to\n * fit into the available process memory.\n * @property {string?} user The name of the user for the remote authentication.\n * @property {string?} pass The password for the remote authentication.\n * @property {string?} method The http multipart upload method name. The 'PUT' one is used by default.\n * @property {Object?} headers Additional headers mapping for multipart http(s) uploads\n * @property {string?} fileFieldName [file] The name of the form field, where the file content BLOB should be stored for\n * http(s) uploads\n * @property {Object|Array<Pair>?} formFields Additional form fields for multipart http(s) uploads\n * @property {number?} uploadTimeout - The actual media upload request timeout in milliseconds;\n * defaults to @appium/support net DEFAULT_TIMEOUT_MS\n */\n\n/**\n * Stop a media projection-based recording.\n * If no recording has been started before then an error is thrown.\n * If the recording has been already finished before this API has been called\n * then the most recent recorded file is returned.\n *\n * @param {?StopRecordingOptions} options Available options.\n * @returns {string} Base64-encoded content of the recorded media file if 'remotePath'\n * parameter is falsy or an empty string.\n * @throws {Error} If there was an error while stopping a recording,\n * fetching the content of the remote media file,\n * or if a recording is not supported on the device under test.\n */\ncommands.mobileStopMediaProjectionRecording = async function mobileStopMediaProjectionRecording (options = {}) {\n  await verifyMediaProjectionRecordingIsSupported(this.adb);\n\n  const recorder = new MediaProjectionRecorder(this.adb);\n  if (await recorder.stop()) {\n    this.log.info('Successfully stopped a media projection recording. Pulling the recorded media');\n  } else {\n    this.log.info('Media projection recording is not running. There is nothing to stop');\n  }\n  const recentRecordingPath = await recorder.pullRecent();\n  if (!recentRecordingPath) {\n    throw new Error(`No recent media projection recording have been found. Did you start any?`);\n  }\n\n  const {remotePath} = options;\n  if (_.isEmpty(remotePath)) {\n    const {size} = await fs.stat(recentRecordingPath);\n    this.log.debug(`The size of the resulting media projection recording is ${util.toReadableSizeString(size)}`);\n  }\n  try {\n    return await uploadRecordedMedia(recentRecordingPath, remotePath, options);\n  } finally {\n    await fs.rimraf(path.dirname(recentRecordingPath));\n  }\n};\n\n\nexport { commands };\nexport default commands;\n"],"mappings":"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"}