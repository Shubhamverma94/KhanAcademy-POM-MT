"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
exports.parseWindowProperties = parseWindowProperties;
exports.parseWindows = parseWindows;
require("source-map-support/register");
var _lodash = _interopRequireDefault(require("lodash"));
const WINDOW_TITLE_PATTERN = /^\s+Window\s#\d+\sWindow\{[0-9a-f]+\s\w+\s([\w-]+)\}:$/;
const FRAME_PATTERN = /\bm?[Ff]rame=\[([0-9.-]+),([0-9.-]+)\]\[([0-9.-]+),([0-9.-]+)\]/;
const VIEW_VISIBILITY_PATTERN = /\bmViewVisibility=(0x[0-9a-fA-F]+)/;
const VIEW_VISIBLE = 0x0;
const STATUS_BAR_WINDOW_NAME_PREFIX = 'StatusBar';
const NAVIGATION_BAR_WINDOW_NAME_PREFIX = 'NavigationBar';
const DEFAULT_WINDOW_PROPERTIES = {
  visible: false,
  x: 0,
  y: 0,
  width: 0,
  height: 0
};
const commands = {};
function parseWindowProperties(name, props, log = null) {
  const result = _lodash.default.cloneDeep(DEFAULT_WINDOW_PROPERTIES);
  const propLines = props.join('\n');
  const frameMatch = FRAME_PATTERN.exec(propLines);
  if (!frameMatch) {
    log === null || log === void 0 ? void 0 : log.debug(propLines);
    throw new Error(`Cannot parse the frame size from '${name}' window properties`);
  }
  result.x = parseFloat(frameMatch[1]);
  result.y = parseFloat(frameMatch[2]);
  result.width = parseFloat(frameMatch[3]) - result.x;
  result.height = parseFloat(frameMatch[4]) - result.y;
  const visibilityMatch = VIEW_VISIBILITY_PATTERN.exec(propLines);
  if (!visibilityMatch) {
    log === null || log === void 0 ? void 0 : log.debug(propLines);
    throw new Error(`Cannot parse the visibility value from '${name}' window properties`);
  }
  result.visible = parseInt(visibilityMatch[1], 16) === VIEW_VISIBLE;
  return result;
}
function parseWindows(lines, log = null) {
  const windows = {};
  let currentWindowName = null;
  for (const line of lines.split('\n').map(_lodash.default.trimEnd)) {
    const match = WINDOW_TITLE_PATTERN.exec(line);
    if (match) {
      currentWindowName = match[1];
      windows[currentWindowName] = [];
      continue;
    }
    if (_lodash.default.trim(line).length === 0) {
      currentWindowName = null;
      continue;
    }
    if (currentWindowName && _lodash.default.isArray(windows[currentWindowName])) {
      windows[currentWindowName].push(line);
    }
  }
  if (_lodash.default.isEmpty(windows)) {
    log === null || log === void 0 ? void 0 : log.debug(lines.join('\n'));
    throw new Error('Cannot parse any window information from the dumpsys output');
  }
  const result = {
    statusBar: null,
    navigationBar: null
  };
  for (const [name, props] of _lodash.default.toPairs(windows)) {
    if (name.startsWith(STATUS_BAR_WINDOW_NAME_PREFIX)) {
      result.statusBar = parseWindowProperties(name, props, log);
    } else if (name.startsWith(NAVIGATION_BAR_WINDOW_NAME_PREFIX)) {
      result.navigationBar = parseWindowProperties(name, props, log);
    }
  }
  const unmatchedWindows = [['statusBar', STATUS_BAR_WINDOW_NAME_PREFIX], ['navigationBar', NAVIGATION_BAR_WINDOW_NAME_PREFIX]].filter(([name]) => _lodash.default.isNil(result[name]));
  for (const [window, namePrefix] of unmatchedWindows) {
    log === null || log === void 0 ? void 0 : log.info(`No windows have been found whose title matches to ` + `'${namePrefix}'. Assuming it is invisible. ` + `Only the following windows are available: ${_lodash.default.keys(windows)}`);
    result[window] = _lodash.default.cloneDeep(DEFAULT_WINDOW_PROPERTIES);
  }
  return result;
}
commands.getSystemBars = async function getSystemBars() {
  let stdout;
  try {
    stdout = await this.adb.shell(['dumpsys', 'window', 'windows']);
  } catch (e) {
    throw new Error(`Cannot retrieve system bars details. Original error: ${e.message}`);
  }
  return parseWindows(stdout, this.log);
};
var _default = commands;
exports.default = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJfbG9kYXNoIiwiX2ludGVyb3BSZXF1aXJlRGVmYXVsdCIsInJlcXVpcmUiLCJXSU5ET1dfVElUTEVfUEFUVEVSTiIsIkZSQU1FX1BBVFRFUk4iLCJWSUVXX1ZJU0lCSUxJVFlfUEFUVEVSTiIsIlZJRVdfVklTSUJMRSIsIlNUQVRVU19CQVJfV0lORE9XX05BTUVfUFJFRklYIiwiTkFWSUdBVElPTl9CQVJfV0lORE9XX05BTUVfUFJFRklYIiwiREVGQVVMVF9XSU5ET1dfUFJPUEVSVElFUyIsInZpc2libGUiLCJ4IiwieSIsIndpZHRoIiwiaGVpZ2h0IiwiY29tbWFuZHMiLCJwYXJzZVdpbmRvd1Byb3BlcnRpZXMiLCJuYW1lIiwicHJvcHMiLCJsb2ciLCJyZXN1bHQiLCJfIiwiY2xvbmVEZWVwIiwicHJvcExpbmVzIiwiam9pbiIsImZyYW1lTWF0Y2giLCJleGVjIiwiZGVidWciLCJFcnJvciIsInBhcnNlRmxvYXQiLCJ2aXNpYmlsaXR5TWF0Y2giLCJwYXJzZUludCIsInBhcnNlV2luZG93cyIsImxpbmVzIiwid2luZG93cyIsImN1cnJlbnRXaW5kb3dOYW1lIiwibGluZSIsInNwbGl0IiwibWFwIiwidHJpbUVuZCIsIm1hdGNoIiwidHJpbSIsImxlbmd0aCIsImlzQXJyYXkiLCJwdXNoIiwiaXNFbXB0eSIsInN0YXR1c0JhciIsIm5hdmlnYXRpb25CYXIiLCJ0b1BhaXJzIiwic3RhcnRzV2l0aCIsInVubWF0Y2hlZFdpbmRvd3MiLCJmaWx0ZXIiLCJpc05pbCIsIndpbmRvdyIsIm5hbWVQcmVmaXgiLCJpbmZvIiwia2V5cyIsImdldFN5c3RlbUJhcnMiLCJzdGRvdXQiLCJhZGIiLCJzaGVsbCIsImUiLCJtZXNzYWdlIiwiX2RlZmF1bHQiLCJleHBvcnRzIiwiZGVmYXVsdCJdLCJzb3VyY2VzIjpbIi4uLy4uLy4uL2xpYi9jb21tYW5kcy9zeXN0ZW0tYmFycy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgXyBmcm9tICdsb2Rhc2gnO1xuXG5jb25zdCBXSU5ET1dfVElUTEVfUEFUVEVSTiA9IC9eXFxzK1dpbmRvd1xccyNcXGQrXFxzV2luZG93XFx7WzAtOWEtZl0rXFxzXFx3K1xccyhbXFx3LV0rKVxcfTokLztcbmNvbnN0IEZSQU1FX1BBVFRFUk4gPSAvXFxibT9bRmZdcmFtZT1cXFsoWzAtOS4tXSspLChbMC05Li1dKylcXF1cXFsoWzAtOS4tXSspLChbMC05Li1dKylcXF0vO1xuY29uc3QgVklFV19WSVNJQklMSVRZX1BBVFRFUk4gPSAvXFxibVZpZXdWaXNpYmlsaXR5PSgweFswLTlhLWZBLUZdKykvO1xuLy8gaHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vcmVmZXJlbmNlL2FuZHJvaWQvdmlldy9WaWV3I1ZJU0lCTEVcbmNvbnN0IFZJRVdfVklTSUJMRSA9IDB4MDtcbmNvbnN0IFNUQVRVU19CQVJfV0lORE9XX05BTUVfUFJFRklYID0gJ1N0YXR1c0Jhcic7XG5jb25zdCBOQVZJR0FUSU9OX0JBUl9XSU5ET1dfTkFNRV9QUkVGSVggPSAnTmF2aWdhdGlvbkJhcic7XG5jb25zdCBERUZBVUxUX1dJTkRPV19QUk9QRVJUSUVTID0ge1xuICB2aXNpYmxlOiBmYWxzZSxcbiAgeDogMCwgeTogMCwgd2lkdGg6IDAsIGhlaWdodDogMCxcbn07XG5cbmNvbnN0IGNvbW1hbmRzID0ge307XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gV2luZG93UHJvcGVydGllc1xuICogQHByb3BlcnR5IHtib29sZWFufSB2aXNpYmxlIFdoZXRoZXIgdGhlIHdpbmRvdyBpcyB2aXNpYmxlXG4gKiBAcHJvcGVydHkge251bWJlcn0geCBXaW5kb3cgeCBjb29yZGluYXRlXG4gKiBAcHJvcGVydHkge251bWJlcn0geSBXaW5kb3cgeSBjb29yZGluYXRlXG4gKiBAcHJvcGVydHkge251bWJlcn0gd2lkdGggV2luZG93IHdpZHRoXG4gKiBAcHJvcGVydHkge251bWJlcn0gaGVpZ2h0IFdpbmRvdyBoZWlnaHRcbiAqL1xuXG4vKipcbiAqIFBhcnNlcyB3aW5kb3cgcHJvcGVydGllcyBmcm9tIGFkYiBkdW1wc3lzIG91dHB1dFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBuYW1lIG9mIHRoZSB3aW5kb3cgd2hvc2UgcHJvcGVydGllcyBhcmUgYmVpbmcgcGFyc2VkXG4gKiBAcGFyYW0ge0FycmF5PHN0cmluZz59IHByb3BzIFRoZSBsaXN0IG9mIHBhcnRpY3VsYXIgd2luZG93IHByb3BlcnR5IGxpbmVzLlxuICogQ2hlY2sgdGhlIGNvcnJlc3BvbmRpbmcgdW5pdCB0ZXN0cyBmb3IgbW9yZSBkZXRhaWxzIG9uIHRoZSBpbnB1dCBmb3JtYXQuXG4gKiBAcGFyYW0ge09iamVjdD99IGxvZyBMb2dnZXIgaW5zdGFuY2VcbiAqIEByZXR1cm5zIHtXaW5kb3dQcm9wZXJ0aWVzfSBQYXJzZWQgcHJvcGVydGllcyBvYmplY3RcbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGVyZSB3YXMgYW4gaXNzdWUgd2hpbGUgcGFyc2luZyB0aGUgcHJvcGVydGllcyBzdHJpbmdcbiAqL1xuZnVuY3Rpb24gcGFyc2VXaW5kb3dQcm9wZXJ0aWVzIChuYW1lLCBwcm9wcywgbG9nID0gbnVsbCkge1xuICBjb25zdCByZXN1bHQgPSBfLmNsb25lRGVlcChERUZBVUxUX1dJTkRPV19QUk9QRVJUSUVTKTtcbiAgY29uc3QgcHJvcExpbmVzID0gcHJvcHMuam9pbignXFxuJyk7XG4gIGNvbnN0IGZyYW1lTWF0Y2ggPSBGUkFNRV9QQVRURVJOLmV4ZWMocHJvcExpbmVzKTtcbiAgaWYgKCFmcmFtZU1hdGNoKSB7XG4gICAgbG9nPy5kZWJ1Zyhwcm9wTGluZXMpO1xuICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IHBhcnNlIHRoZSBmcmFtZSBzaXplIGZyb20gJyR7bmFtZX0nIHdpbmRvdyBwcm9wZXJ0aWVzYCk7XG4gIH1cbiAgcmVzdWx0LnggPSBwYXJzZUZsb2F0KGZyYW1lTWF0Y2hbMV0pO1xuICByZXN1bHQueSA9IHBhcnNlRmxvYXQoZnJhbWVNYXRjaFsyXSk7XG4gIHJlc3VsdC53aWR0aCA9IHBhcnNlRmxvYXQoZnJhbWVNYXRjaFszXSkgLSByZXN1bHQueDtcbiAgcmVzdWx0LmhlaWdodCA9IHBhcnNlRmxvYXQoZnJhbWVNYXRjaFs0XSkgLSByZXN1bHQueTtcbiAgY29uc3QgdmlzaWJpbGl0eU1hdGNoID0gVklFV19WSVNJQklMSVRZX1BBVFRFUk4uZXhlYyhwcm9wTGluZXMpO1xuICBpZiAoIXZpc2liaWxpdHlNYXRjaCkge1xuICAgIGxvZz8uZGVidWcocHJvcExpbmVzKTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBwYXJzZSB0aGUgdmlzaWJpbGl0eSB2YWx1ZSBmcm9tICcke25hbWV9JyB3aW5kb3cgcHJvcGVydGllc2ApO1xuICB9XG4gIHJlc3VsdC52aXNpYmxlID0gcGFyc2VJbnQodmlzaWJpbGl0eU1hdGNoWzFdLCAxNikgPT09IFZJRVdfVklTSUJMRTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBFeHRyYWN0cyBzdGF0dXMgYW5kIG5hdmlnYXRpb24gYmFyIGluZm9ybWF0aW9uIGZyb20gdGhlIHdpbmRvdyBtYW5hZ2VyIG91dHB1dC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PHN0cmluZz59IGxpbmVzIE91dHB1dCBmcm9tIGR1bXBzeXMgY29tbWFuZC5cbiAqIENoZWNrIHRoZSBjb3JyZXNwb25kaW5nIHVuaXQgdGVzdHMgZm9yIG1vcmUgZGV0YWlscyBvbiB0aGUgaW5wdXQgZm9ybWF0LlxuICogQHBhcmFtIHtPYmplY3Q/fSBsb2cgTG9nZ2VyIGluc3RhbmNlXG4gKiBAcmV0dXJuIHtPYmplY3R9IEFuIG9iamVjdCBjb250YWluaW5nIHR3byBpdGVtcyB3aGVyZSBrZXlzIGFyZSBzdGF0dXNCYXIgYW5kIG5hdmlnYXRpb25CYXIsXG4gKiBhbmQgdmFsdWVzIGFyZSBjb3JyZXNwb25kaW5nIFdpbmRvd1Byb3BlcnRpZXMgb2JqZWN0c1xuICogQHRocm93cyB7RXJyb3J9IElmIG5vIHdpbmRvdyBwcm9wZXJ0aWVzIGNvdWxkIGJlIHBhcnNlZFxuICovXG5mdW5jdGlvbiBwYXJzZVdpbmRvd3MgKGxpbmVzLCBsb2cgPSBudWxsKSB7XG4gIGNvbnN0IHdpbmRvd3MgPSB7fTtcbiAgbGV0IGN1cnJlbnRXaW5kb3dOYW1lID0gbnVsbDtcbiAgZm9yIChjb25zdCBsaW5lIG9mIGxpbmVzLnNwbGl0KCdcXG4nKS5tYXAoXy50cmltRW5kKSkge1xuICAgIGNvbnN0IG1hdGNoID0gV0lORE9XX1RJVExFX1BBVFRFUk4uZXhlYyhsaW5lKTtcbiAgICBpZiAobWF0Y2gpIHtcbiAgICAgIGN1cnJlbnRXaW5kb3dOYW1lID0gbWF0Y2hbMV07XG4gICAgICB3aW5kb3dzW2N1cnJlbnRXaW5kb3dOYW1lXSA9IFtdO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChfLnRyaW0obGluZSkubGVuZ3RoID09PSAwKSB7XG4gICAgICBjdXJyZW50V2luZG93TmFtZSA9IG51bGw7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAoY3VycmVudFdpbmRvd05hbWUgJiYgXy5pc0FycmF5KHdpbmRvd3NbY3VycmVudFdpbmRvd05hbWVdKSkge1xuICAgICAgd2luZG93c1tjdXJyZW50V2luZG93TmFtZV0ucHVzaChsaW5lKTtcbiAgICB9XG4gIH1cbiAgaWYgKF8uaXNFbXB0eSh3aW5kb3dzKSkge1xuICAgIGxvZz8uZGVidWcobGluZXMuam9pbignXFxuJykpO1xuICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHBhcnNlIGFueSB3aW5kb3cgaW5mb3JtYXRpb24gZnJvbSB0aGUgZHVtcHN5cyBvdXRwdXQnKTtcbiAgfVxuXG4gIGNvbnN0IHJlc3VsdCA9IHtzdGF0dXNCYXI6IG51bGwsIG5hdmlnYXRpb25CYXI6IG51bGx9O1xuICBmb3IgKGNvbnN0IFtuYW1lLCBwcm9wc10gb2YgXy50b1BhaXJzKHdpbmRvd3MpKSB7XG4gICAgaWYgKG5hbWUuc3RhcnRzV2l0aChTVEFUVVNfQkFSX1dJTkRPV19OQU1FX1BSRUZJWCkpIHtcbiAgICAgIHJlc3VsdC5zdGF0dXNCYXIgPSBwYXJzZVdpbmRvd1Byb3BlcnRpZXMobmFtZSwgcHJvcHMsIGxvZyk7XG4gICAgfSBlbHNlIGlmIChuYW1lLnN0YXJ0c1dpdGgoTkFWSUdBVElPTl9CQVJfV0lORE9XX05BTUVfUFJFRklYKSkge1xuICAgICAgcmVzdWx0Lm5hdmlnYXRpb25CYXIgPSBwYXJzZVdpbmRvd1Byb3BlcnRpZXMobmFtZSwgcHJvcHMsIGxvZyk7XG4gICAgfVxuICB9XG4gIGNvbnN0IHVubWF0Y2hlZFdpbmRvd3MgPSBbXG4gICAgWydzdGF0dXNCYXInLCBTVEFUVVNfQkFSX1dJTkRPV19OQU1FX1BSRUZJWF0sXG4gICAgWyduYXZpZ2F0aW9uQmFyJywgTkFWSUdBVElPTl9CQVJfV0lORE9XX05BTUVfUFJFRklYXVxuICBdLmZpbHRlcigoW25hbWVdKSA9PiBfLmlzTmlsKHJlc3VsdFtuYW1lXSkpO1xuICBmb3IgKGNvbnN0IFt3aW5kb3csIG5hbWVQcmVmaXhdIG9mIHVubWF0Y2hlZFdpbmRvd3MpIHtcbiAgICBsb2c/LmluZm8oYE5vIHdpbmRvd3MgaGF2ZSBiZWVuIGZvdW5kIHdob3NlIHRpdGxlIG1hdGNoZXMgdG8gYCArXG4gICAgICBgJyR7bmFtZVByZWZpeH0nLiBBc3N1bWluZyBpdCBpcyBpbnZpc2libGUuIGAgK1xuICAgICAgYE9ubHkgdGhlIGZvbGxvd2luZyB3aW5kb3dzIGFyZSBhdmFpbGFibGU6ICR7Xy5rZXlzKHdpbmRvd3MpfWApO1xuICAgIHJlc3VsdFt3aW5kb3ddID0gXy5jbG9uZURlZXAoREVGQVVMVF9XSU5ET1dfUFJPUEVSVElFUyk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuY29tbWFuZHMuZ2V0U3lzdGVtQmFycyA9IGFzeW5jIGZ1bmN0aW9uIGdldFN5c3RlbUJhcnMgKCkge1xuICBsZXQgc3Rkb3V0O1xuICB0cnkge1xuICAgIHN0ZG91dCA9IGF3YWl0IHRoaXMuYWRiLnNoZWxsKFsnZHVtcHN5cycsICd3aW5kb3cnLCAnd2luZG93cyddKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IHJldHJpZXZlIHN5c3RlbSBiYXJzIGRldGFpbHMuIE9yaWdpbmFsIGVycm9yOiAke2UubWVzc2FnZX1gKTtcbiAgfVxuICByZXR1cm4gcGFyc2VXaW5kb3dzKHN0ZG91dCwgdGhpcy5sb2cpO1xufTtcblxuLy8gZm9yIHVuaXQgdGVzdHNcbmV4cG9ydCB7IHBhcnNlV2luZG93cywgcGFyc2VXaW5kb3dQcm9wZXJ0aWVzIH07XG5leHBvcnQgZGVmYXVsdCBjb21tYW5kcztcbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBLElBQUFBLE9BQUEsR0FBQUMsc0JBQUEsQ0FBQUMsT0FBQTtBQUVBLE1BQU1DLG9CQUFvQixHQUFHLHdEQUF3RDtBQUNyRixNQUFNQyxhQUFhLEdBQUcsaUVBQWlFO0FBQ3ZGLE1BQU1DLHVCQUF1QixHQUFHLG9DQUFvQztBQUVwRSxNQUFNQyxZQUFZLEdBQUcsR0FBRztBQUN4QixNQUFNQyw2QkFBNkIsR0FBRyxXQUFXO0FBQ2pELE1BQU1DLGlDQUFpQyxHQUFHLGVBQWU7QUFDekQsTUFBTUMseUJBQXlCLEdBQUc7RUFDaENDLE9BQU8sRUFBRSxLQUFLO0VBQ2RDLENBQUMsRUFBRSxDQUFDO0VBQUVDLENBQUMsRUFBRSxDQUFDO0VBQUVDLEtBQUssRUFBRSxDQUFDO0VBQUVDLE1BQU0sRUFBRTtBQUNoQyxDQUFDO0FBRUQsTUFBTUMsUUFBUSxHQUFHLENBQUMsQ0FBQztBQXFCbkIsU0FBU0MscUJBQXFCQSxDQUFFQyxJQUFJLEVBQUVDLEtBQUssRUFBRUMsR0FBRyxHQUFHLElBQUksRUFBRTtFQUN2RCxNQUFNQyxNQUFNLEdBQUdDLGVBQUMsQ0FBQ0MsU0FBUyxDQUFDYix5QkFBeUIsQ0FBQztFQUNyRCxNQUFNYyxTQUFTLEdBQUdMLEtBQUssQ0FBQ00sSUFBSSxDQUFDLElBQUksQ0FBQztFQUNsQyxNQUFNQyxVQUFVLEdBQUdyQixhQUFhLENBQUNzQixJQUFJLENBQUNILFNBQVMsQ0FB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