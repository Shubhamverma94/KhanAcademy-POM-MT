{"version":3,"file":"app-management.js","names":["_lodash","_interopRequireDefault","require","_asyncbox","_support","_androidHelpers","_driver","_utils","APP_EXTENSIONS","RESOLVER_ACTIVITY_NAME","commands","exports","isAppInstalled","appId","adb","mobileIsAppInstalled","opts","requireArgs","queryAppState","log","info","APP_STATE","NOT_INSTALLED","processExists","NOT_RUNNING","appIdRe","RegExp","_","escapeRegExp","line","dumpWindows","split","test","some","x","includes","RUNNING_IN_FOREGROUND","RUNNING_IN_BACKGROUND","mobileQueryAppState","activateApp","debug","apiLevel","getApiLevel","cmd","output","shell","e","errorAndThrow","message","activityName","resolveLaunchableActivity","preferCmd","stdout","Error","mobileActivateApp","removeApp","options","uninstallApk","mobileRemoveApp","terminateApp","forceStop","timeout","util","hasValue","isNaN","parseInt","waitForCondition","waitMs","intervalMs","mobileTerminateApp","installApp","appPath","localPath","helpers","configureApp","install","mobileInstallApp","mobileClearApp","errors","InvalidArgumentError","clear","_default","default"],"sources":["../../../lib/commands/app-management.js"],"sourcesContent":["import _ from 'lodash';\nimport { waitForCondition } from 'asyncbox';\nimport { util } from '@appium/support';\nimport { APP_STATE } from '../android-helpers';\nimport { errors } from 'appium/driver';\nimport { requireArgs } from '../utils';\n\nconst APP_EXTENSIONS = ['.apk', '.apks'];\nconst RESOLVER_ACTIVITY_NAME = 'android/com.android.internal.app.ResolverActivity';\n\nconst commands = {};\n\n/**\n * Verify whether an application is installed or not\n *\n * @param {string} appId - Application package identifier\n * @returns {boolean} true if the app is installed\n */\ncommands.isAppInstalled = async function isAppInstalled (appId) {\n  return await this.adb.isAppInstalled(appId);\n};\n\n/**\n * @typedef {Object} MobileAppInstalledOptions\n * @property {string} appId - Application package identifier. Must be always provided.\n */\n\n/**\n * Verify whether an application is installed or not\n *\n * @param {MobileAppInstalledOptions} opts\n * @returns {boolean} Same as in `isAppInstalled`\n */\ncommands.mobileIsAppInstalled = async function mobileIsAppInstalled (opts = {}) {\n  const { appId } = requireArgs('appId', opts);\n  return await this.isAppInstalled(appId);\n};\n\n/**\n * Queries the current state of the app.\n *\n * @param {string} appId - Application package identifier\n * @returns {number} The corresponding constant, which describes\n *                   the current application state:\n * 0 - is the app is not installed\n * 1 - if the app is installed, but is not running\n * 3 - if the app is running in the background\n * 4 - if the app is running in the foreground\n */\ncommands.queryAppState = async function queryAppState (appId) {\n  this.log.info(`Querying the state of '${appId}'`);\n  if (!await this.adb.isAppInstalled(appId)) {\n    return APP_STATE.NOT_INSTALLED;\n  }\n  if (!await this.adb.processExists(appId)) {\n    return APP_STATE.NOT_RUNNING;\n  }\n  const appIdRe = new RegExp(`\\\\b${_.escapeRegExp(appId)}/`);\n  for (const line of (await this.adb.dumpWindows()).split('\\n')) {\n    if (appIdRe.test(line) && ['mCurrentFocus', 'mFocusedApp'].some((x) => line.includes(x))) {\n      return APP_STATE.RUNNING_IN_FOREGROUND;\n    }\n  }\n  return APP_STATE.RUNNING_IN_BACKGROUND;\n};\n\n/**\n * @typedef {Object} MobileQueryAppStateOptions\n * @property {string} appId - Application package identifier. Must be always provided.\n */\n\n/**\n * Queries the current state of the app.\n *\n * @param {MobileQueryAppStateOptions} opts\n * @returns {number} Same as in `queryAppState`\n */\ncommands.mobileQueryAppState = async function mobileQueryAppState (opts = {}) {\n  const { appId } = requireArgs('appId', opts);\n  return await this.queryAppState(appId);\n};\n\n/**\n * Activates the given application or launches it if necessary.\n * The action literally simulates\n * clicking the corresponding application icon on the dashboard.\n *\n * @param {string} appId - Application package identifier\n * @throws {Error} If the app cannot be activated\n */\ncommands.activateApp = async function activateApp (appId) {\n  this.log.debug(`Activating '${appId}'`);\n  const apiLevel = await this.adb.getApiLevel();\n  // Fallback to Monkey in older APIs\n  if (apiLevel < 24) {\n    // The monkey command could raise an issue as https://stackoverflow.com/questions/44860475/how-to-use-the-monkey-command-with-an-android-system-that-doesnt-have-physical\n    // but '--pct-syskeys 0' could cause another background process issue. https://github.com/appium/appium/issues/16941#issuecomment-1129837285\n    const cmd = ['monkey',\n      '-p', appId,\n      '-c', 'android.intent.category.LAUNCHER',\n      '1'];\n    let output = '';\n    try {\n      output = await this.adb.shell(cmd);\n      this.log.debug(`Command stdout: ${output}`);\n    } catch (e) {\n      this.log.errorAndThrow(`Cannot activate '${appId}'. Original error: ${e.message}`);\n    }\n    if (output.includes('monkey aborted')) {\n      this.log.errorAndThrow(`Cannot activate '${appId}'. Are you sure it is installed?`);\n    }\n    return;\n  }\n\n  let activityName = await this.adb.resolveLaunchableActivity(appId);\n  if (activityName === RESOLVER_ACTIVITY_NAME) {\n    // https://github.com/appium/appium/issues/17128\n    this.log.debug(\n      `The launchable activity name of '${appId}' was resolved to '${activityName}'. ` +\n      `Switching the resolver to not use cmd`\n    );\n    activityName = await this.adb.resolveLaunchableActivity(appId, {preferCmd: false});\n  }\n\n  const stdout = await this.adb.shell([\n    'am', (apiLevel < 26) ? 'start' : 'start-activity',\n    '-a', 'android.intent.action.MAIN',\n    '-c', 'android.intent.category.LAUNCHER',\n    // FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_RESET_TASK_IF_NEEDED\n    // https://developer.android.com/reference/android/content/Intent#FLAG_ACTIVITY_NEW_TASK\n    // https://developer.android.com/reference/android/content/Intent#FLAG_ACTIVITY_RESET_TASK_IF_NEEDED\n    '-f', '0x10200000',\n    '-n', activityName,\n  ]);\n  this.log.debug(stdout);\n  if (/^error:/mi.test(stdout)) {\n    throw new Error(`Cannot activate '${appId}'. Original error: ${stdout}`);\n  }\n};\n\n/**\n * @typedef {Object} MobileActivateAppOptions\n * @property {string} appId - Application package identifier. Must be always provided.\n */\n\n/**\n * Activates the given application or launches it if necessary.\n * The action literally simulates\n * clicking the corresponding application icon on the dashboard.\n *\n * @param {MobileActivateAppOptions} opts\n * @throws {Error} If the app cannot be activated\n */\ncommands.mobileActivateApp = async function mobileActivateApp (opts = {}) {\n  const { appId } = requireArgs('appId', opts);\n  return await this.activateApp(appId);\n};\n\n/**\n * @typedef {Object} UninstallOptions\n * @property {number} timeout [20000] - The count of milliseconds to wait until the\n *                                      app is uninstalled.\n * @property {boolean} keepData [false] - Set to true in order to keep the\n *                                        application data and cache folders after uninstall.\n */\n\n/**\n * Remove the corresponding application if is installed.\n * The call is ignored if the app is not installed.\n *\n * @param {string} appId - Application package identifier\n * @param {?UninstallOptions} options - The set of removal options\n * @returns {boolean} True if the package was found on the device and\n *                    successfully uninstalled.\n */\ncommands.removeApp = async function removeApp (appId, options = {}) {\n  return await this.adb.uninstallApk(appId, options);\n};\n\n/**\n * @typedef {Object} MobileRemoveAppOptions\n * @property {string} appId - Application package identifier. Must be always provided.\n */\n\n/**\n * Remove the corresponding application if is installed.\n * The call is ignored if the app is not installed.\n *\n * @param {MobileRemoveAppOptions} opts\n * @returns {boolean} Same as in `removeApp`\n */\ncommands.mobileRemoveApp = async function mobileRemoveApp (opts = {}) {\n  const { appId } = requireArgs('appId', opts);\n  return await this.removeApp(appId, opts);\n};\n\n/**\n * @typedef {Object} TerminateOptions\n * @property {number|string} timeout [500] - The count of milliseconds to wait until the\n *                                           app is terminated. The method will skip\n *                                           checking the app state check if the timeout\n *                                           was lower or equal to zero. Then, the return\n *                                           value will be true.\n */\n\n/**\n * Terminates the app if it is running. If the given timeout was lower or equal to zero,\n * it returns true after terminating the app without checking the app state.\n *\n * @param {string} appId - Application package identifier\n * @param {?TerminateOptions} options - The set of application termination options\n * @returns {boolean} True if the app has been successfully terminated.\n * @throws {Error} if the app has not been terminated within the given timeout.\n */\ncommands.terminateApp = async function terminateApp (appId, options = {}) {\n  this.log.info(`Terminating '${appId}'`);\n  if (!(await this.adb.processExists(appId))) {\n    this.log.info(`The app '${appId}' is not running`);\n    return false;\n  }\n  await this.adb.forceStop(appId);\n  const timeout = util.hasValue(options.timeout) && !isNaN(options.timeout) ? parseInt(options.timeout, 10) : 500;\n\n  if (timeout <= 0) {\n    this.log.info(`'${appId}' has been terminated. Skip checking the application process state ` +\n      `since the timeout was set as ${timeout}ms`);\n    return true;\n  }\n\n  try {\n    await waitForCondition(async () => await this.queryAppState(appId) <= APP_STATE.NOT_RUNNING,\n      {waitMs: timeout, intervalMs: 100});\n  } catch (e) {\n    this.log.errorAndThrow(`'${appId}' is still running after ${timeout}ms timeout`);\n  }\n  this.log.info(`'${appId}' has been successfully terminated`);\n  return true;\n};\n\n/**\n * @typedef {Object} MobileTerminateAppOptions\n * @property {string} appId - Application package identifier. Must be always provided.\n * @property {number|string} timeout [500] - The count of milliseconds to wait until the\n *                                           app is terminated.\n */\n\n/**\n * Terminates the app if it is running.\n *\n * @param {MobileTerminateAppOptions} opts\n * @returns {boolean} Same as in `terminateApp`\n * @throws {Error} if the app has not been terminated within the given timeout.\n */\ncommands.mobileTerminateApp = async function mobileTerminateApp (opts = {}) {\n  const { appId } = requireArgs('appId', opts);\n  return await this.terminateApp(appId, opts);\n};\n\n/**\n * @typedef {Object} InstallOptions\n * @property {number} timeout [60000] - The count of milliseconds to wait until the\n *                                      app is installed.\n * @property {boolean} allowTestPackages [false] - Set to true in order to allow test\n *                                                 packages installation.\n * @property {boolean} useSdcard [false] - Set to true to install the app on sdcard\n *                                         instead of the device memory.\n * @property {boolean} grantPermissions [false] - Set to true in order to grant all the\n *                                                permissions requested in the application's manifest\n *                                                automatically after the installation is completed\n *                                                under Android 6+.\n * @property {boolean} replace [true] - Set it to false if you don't want\n *                                      the application to be upgraded/reinstalled\n *                                      if it is already present on the device.\n */\n\n/**\n * Installs the given application to the device under test\n *\n * @param {string} appPath - The local apk path or a remote url\n * @param {?InstallOptions} options - The set of installation options\n * @throws {Error} if the given apk does not exist or is not reachable\n */\ncommands.installApp = async function installApp (appPath, options = {}) {\n  const localPath = await this.helpers.configureApp(appPath, APP_EXTENSIONS);\n  await this.adb.install(localPath, options);\n};\n\n/**\n * @typedef {Object} MobileInstallAppOptions\n * @property {string} appPath - The local apk path or a remote url. Must be always provided.\n * @property {number} timeout [60000] - The count of milliseconds to wait until the\n *                                      app is installed.\n * @property {boolean} allowTestPackages [false] - Set to true in order to allow test\n *                                                 packages installation.\n * @property {boolean} useSdcard [false] - Set to true to install the app on sdcard\n *                                         instead of the device memory.\n * @property {boolean} grantPermissions [false] - Set to true in order to grant all the\n *                                                permissions requested in the application's manifest\n *                                                automatically after the installation is completed\n *                                                under Android 6+.\n * @property {boolean} replace [true] - Set it to false if you don't want\n *                                      the application to be upgraded/reinstalled\n *                                      if it is already present on the device.\n */\n\n/**\n * Installs the given application to the device under test\n *\n * @param {MobileInstallAppOptions} opts\n * @throws {Error} if the given apk does not exist or is not reachable\n */\ncommands.mobileInstallApp = async function mobileInstallApp (opts = {}) {\n  const { appPath } = requireArgs('appPath', opts);\n  return await this.installApp(appPath, opts);\n};\n\n/**\n * @typedef {Object} ClearAppOptions\n * @property {!string} appId The identifier of the application package to be cleared\n */\n\n/**\n * Deletes all data associated with a package.\n *\n * @param {ClearAppOptions} opts\n * @throws {Error} If cleaning of the app data fails\n */\ncommands.mobileClearApp = async function mobileClearApp (opts = {}) {\n  const {appId} = opts;\n  if (!appId) {\n    throw new errors.InvalidArgumentError(`The 'appId' argument is required`);\n  }\n  await this.adb.clear(appId);\n};\n\nexport { commands };\nexport default commands;\n"],"mappings":"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"}