{"version":3,"file":"file-actions.js","names":["_lodash","_interopRequireDefault","require","_support","_path","_driver","_utils","CONTAINER_PATH_MARKER","CONTAINER_PATH_PATTERN","RegExp","ANDROID_MEDIA_RESCAN_INTENT","commands","exports","parseContainerPath","remotePath","match","exec","Error","path","posix","resolve","scanMedia","adb","log","debug","getApiLevel","shell","e","warn","stderr","message","escapePath","p","replace","pullFile","endsWith","errors","InvalidArgumentError","tmpDestination","startsWith","packageId","pathInContainer","basename","errorAndThrow","localFile","tempDir","prefix","suffix","pull","util","toInMemoryBase64","toString","fs","exists","unlink","mobilePullFile","opts","requireArgs","pushFile","base64Data","_","isArray","Buffer","from","content","writeFile","dirname","push","mobilePushFile","payload","pullFolder","tmpRoot","openDir","zip","toInMemoryZip","encodeToBase64","rimraf","mobilePullFolder","deleteFileOrFolder","performRemoteFsCheck","op","runAs","passFlag","checkCmd","fullCmd","includes","ign","isFile","isDir","isPresent","dstPath","pkgId","info","expectsFile","mobileDeleteFile","_default","default"],"sources":["../../../lib/commands/file-actions.js"],"sourcesContent":["import _ from 'lodash';\nimport { fs, util, zip, tempDir } from '@appium/support';\nimport path from 'path';\nimport { errors } from 'appium/driver';\nimport { requireArgs } from '../utils';\n\n\nconst CONTAINER_PATH_MARKER = '@';\n// https://regex101.com/r/PLdB0G/2\nconst CONTAINER_PATH_PATTERN = new RegExp(`^${CONTAINER_PATH_MARKER}([^/]+)/(.+)`);\nconst ANDROID_MEDIA_RESCAN_INTENT = 'android.intent.action.MEDIA_SCANNER_SCAN_FILE';\n\n\nconst commands = {};\n\n/**\n * Parses the actual destination path from the given value\n *\n * @param {string} remotePath The preformatted remote path, which looks like\n * `@my.app.id/my/path`\n * @returns {Array<string>} An array, where the first item is the parsed package\n * identifier and the second one is the actual destination path inside the package.\n * @throws {Error} If the given string cannot be parsed\n */\nfunction parseContainerPath (remotePath) {\n  const match = CONTAINER_PATH_PATTERN.exec(remotePath);\n  if (!match) {\n    throw new Error(`It is expected that package identifier is separated from the relative path with a single slash. ` +\n      `'${remotePath}' is given instead`);\n  }\n  return [match[1], path.posix.resolve(`/data/data/${match[1]}`, match[2])];\n}\n\n/**\n * Scans the given file/folder on the remote device\n * and adds matching items to the device's media library.\n * Exceptions are ignored and written into the log.\n *\n * @param {ADB} adb ADB instance\n * @param {Object?} log Logger instance\n * @param {string} remotePath The file/folder path on the remote device\n */\nasync function scanMedia (adb, remotePath, log = null) {\n  log?.debug(`Performing media scan of '${remotePath}'`);\n  try {\n    // https://github.com/appium/appium/issues/16184\n    if (await adb.getApiLevel() >= 29) {\n      await adb.scanMedia(remotePath);\n    } else {\n      await adb.shell([\n        'am', 'broadcast',\n        '-a', ANDROID_MEDIA_RESCAN_INTENT,\n        '-d', `file://${remotePath}`\n      ]);\n    }\n  } catch (e) {\n    log?.warn(`Ignoring an unexpected error upon media scanning of '${remotePath}': ${e.stderr || e.message}`);\n  }\n}\n\n/**\n * A small helper, which escapes single quotes in paths,\n * so they are safe to be passed as arguments of shell commands\n *\n * @param {string} p The initial remote path\n * @returns {string} The escaped path value\n */\nfunction escapePath (p) {\n  return p.replace(/'/g, `\\\\'`);\n}\n\n/**\n * Pulls a remote file from the device.\n * It is required, that a package has debugging flag enabled\n * in order to access its files.\n *\n * @param {string} remotePath The full path to the remote file\n * or a specially formatted path, which points to an item inside app bundle\n * @returns {string} Base64 encoded content of the pulled file\n * @throws {Error} If the pull operation failed\n */\ncommands.pullFile = async function pullFile (remotePath) {\n  if (remotePath.endsWith('/')) {\n    throw new errors.InvalidArgumentError(`It is expected that remote path points to a file and not to a folder. ` +\n      `'${remotePath}' is given instead`);\n  }\n  let tmpDestination = null;\n  if (remotePath.startsWith(CONTAINER_PATH_MARKER)) {\n    const [packageId, pathInContainer] = parseContainerPath(remotePath);\n    this.log.debug(`Parsed package identifier '${packageId}' from '${remotePath}'. Will get the data from '${pathInContainer}'`);\n    tmpDestination = `/data/local/tmp/${path.posix.basename(pathInContainer)}`;\n    try {\n      await this.adb.shell(['run-as', packageId, `chmod 777 '${escapePath(pathInContainer)}'`]);\n      await this.adb.shell([\n        'run-as', packageId,\n        `cp -f '${escapePath(pathInContainer)}' '${escapePath(tmpDestination)}'`\n      ]);\n    } catch (e) {\n      this.log.errorAndThrow(`Cannot access the container of '${packageId}' application. ` +\n                        `Is the application installed and has 'debuggable' build option set to true? ` +\n                        `Original error: ${e.message}`);\n    }\n  }\n  const localFile = await tempDir.path({prefix: 'appium', suffix: '.tmp'});\n  try {\n    await this.adb.pull(tmpDestination || remotePath, localFile);\n    return (await util.toInMemoryBase64(localFile)).toString();\n  } finally {\n    if (await fs.exists(localFile)) {\n      await fs.unlink(localFile);\n    }\n    if (tmpDestination) {\n      await this.adb.shell(['rm', '-f', tmpDestination]);\n    }\n  }\n};\n\n/**\n * @typedef {Object} PullFileOptions\n * @property {string} remotePath The full path to the remote file\n * or a specially formatted path, which points to an item inside an app bundle,\n * for example `@my.app.id/my/path`. It is mandatory for the app bundle to have\n * debugging enabled in order to use the latter remotePath format.\n */\n\n/**\n * Pulls a remote file from the device.\n *\n * @param {PullFileOptions} opts\n * @returns {string} The same as `pullFile`\n */\ncommands.mobilePullFile = async function mobilePullFile (opts = {}) {\n  const { remotePath } = requireArgs('remotePath', opts);\n  return await this.pullFile(remotePath);\n};\n\n/**\n * Pushes the given data to a file on the remote device\n * It is required, that a package has debugging flag enabled\n * in order to access its files.\n * After a file is pushed it gets automatically scanned for possible\n * media occurrences. If the scan succeeds then the file is added to the\n * media library.\n *\n * @param {string} remotePath The full path to the remote file or\n * a file inside a package bundle\n * @param {string} base64Data Base64 encoded data to be written to the\n * remote file. The remote file will be silently overridden if it already exists.\n * @throws {Error} If there was an error while pushing the data\n */\ncommands.pushFile = async function pushFile (remotePath, base64Data) {\n  if (remotePath.endsWith('/')) {\n    throw new errors.InvalidArgumentError(\n      `It is expected that remote path points to a file and not to a folder. ` +\n      `'${remotePath}' is given instead`\n    );\n  }\n  const localFile = await tempDir.path({prefix: 'appium', suffix: '.tmp'});\n  if (_.isArray(base64Data)) {\n    // some clients (ahem) java, send a byte array encoding utf8 characters\n    // instead of a string, which would be infinitely better!\n    base64Data = Buffer.from(base64Data).toString('utf8');\n  }\n  const content = Buffer.from(base64Data, 'base64');\n  let tmpDestination = null;\n  try {\n    await fs.writeFile(localFile, content.toString('binary'), 'binary');\n    if (remotePath.startsWith(CONTAINER_PATH_MARKER)) {\n      const [packageId, pathInContainer] = parseContainerPath(remotePath);\n      this.log.debug(`Parsed package identifier '${packageId}' from '${remotePath}'. ` +\n        `Will put the data into '${pathInContainer}'`);\n      tmpDestination = `/data/local/tmp/${path.posix.basename(pathInContainer)}`;\n      try {\n        await this.adb.shell(\n          ['run-as', packageId, `mkdir -p '${escapePath(path.posix.dirname(pathInContainer))}'`]\n        );\n        await this.adb.shell(['run-as', packageId, `touch '${escapePath(pathInContainer)}'`]);\n        await this.adb.shell(['run-as', packageId, `chmod 777 '${escapePath(pathInContainer)}'`]);\n        await this.adb.push(localFile, tmpDestination);\n        await this.adb.shell([\n          'run-as', packageId,\n          `cp -f '${escapePath(tmpDestination)}' '${escapePath(pathInContainer)}'`\n        ]);\n      } catch (e) {\n        this.log.errorAndThrow(`Cannot access the container of '${packageId}' application. ` +\n                          `Is the application installed and has 'debuggable' build option set to true? ` +\n                          `Original error: ${e.message}`);\n      }\n    } else {\n      // adb push creates folders and overwrites existing files.\n      await this.adb.push(localFile, remotePath);\n\n      // if we have pushed a file, it might be a media file, so ensure that\n      // apps know about it\n      await scanMedia(this.adb, remotePath, this.log);\n    }\n  } finally {\n    if (await fs.exists(localFile)) {\n      await fs.unlink(localFile);\n    }\n    if (tmpDestination) {\n      await this.adb.shell(['rm', '-f', tmpDestination]);\n    }\n  }\n};\n\n/**\n * @typedef {Object} PushFileOptions\n * @property {string} remotePath The full path to the remote file\n * or a specially formatted path, which points to an item inside an app bundle,\n * for example `@my.app.id/my/path`. It is mandatory for the app bundle to have\n * debugging enabled in order to use the latter remotePath format.\n * @property {string} payload Base64-encoded content of the file to be pushed.\n */\n\n/**\n * Pushes the given data to a file on the remote device.\n *\n * @param {PushFileOptions} opts\n */\ncommands.mobilePushFile = async function mobilePushFile (opts = {}) {\n  const { remotePath, payload } = requireArgs(['remotePath', 'payload'], opts);\n  return await this.pushFile(remotePath, payload);\n};\n\n/**\n * Pulls the whole folder from the remote device\n *\n * @param {string} remotePath The full path to a folder on the\n * remote device or a folder inside an application bundle\n * @returns {string} Base64-encoded and zipped content of the folder\n * @throws {Error} If there was a failure while getting the folder content\n */\ncommands.pullFolder = async function pullFolder (remotePath) {\n  const tmpRoot = await tempDir.openDir();\n  try {\n    await this.adb.pull(remotePath, tmpRoot);\n    return (await zip.toInMemoryZip(tmpRoot, {\n      encodeToBase64: true,\n    })).toString();\n  } finally {\n    await fs.rimraf(tmpRoot);\n  }\n};\n\n/**\n * @typedef {Object} PullFolderOptions\n * @property {string} remotePath The full path to the remote folder.\n */\n\n/**\n * Pulls the whole folder from the device under test.\n *\n * @param {PullFolderOptions} opts\n * @returns {string} The same as `pullFolder`\n */\ncommands.mobilePullFolder = async function mobilePullFolder (opts = {}) {\n  const { remotePath } = requireArgs('remotePath', opts);\n  return await this.pullFolder(remotePath);\n};\n\n/**\n * Deletes the given folder or file from the remote device\n *\n * @param {ADB} adb\n * @param {string} remotePath The full path to the remote folder\n * or file (folder names must end with a single slash)\n * @throws {Error} If the provided remote path is invalid or\n * the package content cannot be accessed\n * @returns {boolean} `true` if the remote item has been successfully deleted.\n * If the remote path is valid, but the remote path does not exist\n * this function return `false`.\n */\nasync function deleteFileOrFolder (adb, remotePath) {\n  const performRemoteFsCheck = async (p, op, runAs = null) => {\n    const passFlag = '__PASS__';\n    const checkCmd = `[ -${op} '${escapePath(p)}' ] && echo ${passFlag}`;\n    const fullCmd = runAs ? `run-as ${runAs} ${checkCmd}` : checkCmd;\n    try {\n      return _.includes(await adb.shell([fullCmd]), passFlag);\n    } catch (ign) {\n      return false;\n    }\n  };\n  const isFile = async (p, runAs = null) => await performRemoteFsCheck(p, 'f', runAs);\n  const isDir = async (p, runAs = null) => await performRemoteFsCheck(p, 'd', runAs);\n  const isPresent = async (p, runAs = null) => await performRemoteFsCheck(p, 'e', runAs);\n\n  let dstPath = remotePath;\n  let pkgId = null;\n  if (remotePath.startsWith(CONTAINER_PATH_MARKER)) {\n    const [packageId, pathInContainer] = parseContainerPath(remotePath);\n    this.log.debug(`Parsed package identifier '${packageId}' from '${remotePath}'`);\n    dstPath = pathInContainer;\n    pkgId = packageId;\n  }\n\n  if (pkgId) {\n    try {\n      await adb.shell(['run-as', pkgId, 'ls']);\n    } catch (e) {\n      this.log.errorAndThrow(`Cannot access the container of '${pkgId}' application. ` +\n        `Is the application installed and has 'debuggable' build option set to true? ` +\n        `Original error: ${e.message}`);\n    }\n  }\n\n  if (!await isPresent(dstPath, pkgId)) {\n    this.log.info(`The item at '${dstPath}' does not exist. Perhaps, already deleted?`);\n    return false;\n  }\n\n  const expectsFile = !remotePath.endsWith('/');\n  if (expectsFile && !await isFile(dstPath, pkgId)) {\n    this.log.errorAndThrow(`The item at '${dstPath}' is not a file`);\n  } else if (!expectsFile && !await isDir(dstPath, pkgId)) {\n    this.log.errorAndThrow(`The item at '${dstPath}' is not a folder`);\n  }\n\n  if (pkgId) {\n    await adb.shell(\n      ['run-as', pkgId, `rm -f${expectsFile ? '' : 'r'} '${escapePath(dstPath)}'`]);\n  } else {\n    await adb.shell(['rm', `-f${expectsFile ? '' : 'r'}`, dstPath]);\n  }\n  if (await isPresent(dstPath, pkgId)) {\n    this.log.errorAndThrow(`The item at '${dstPath}' still exists after being deleted. ` +\n      `Is it writable?`);\n  }\n  return true;\n}\n\n/**\n * @typedef {Object} DeleteFileOpts\n * @property {!string} remotePath The full path to the remote file\n * or a file inside an application bundle (for example `@my.app.id/path/in/bundle`)\n */\n\n/**\n * Deletes a file on the remote device\n *\n * @param {DeleteFileOpts} opts\n * @returns {boolean} `true` if the remote file has been successfully deleted.\n * If the path to a remote file is valid, but the file itself does not exist\n * then `false` is returned.\n * @throws {Error} If the argument is invalid or there was an error while\n * deleting the file\n */\ncommands.mobileDeleteFile = async function mobileDeleteFile (opts = {}) {\n  const {remotePath} = opts;\n  if (!remotePath) {\n    throw new errors.InvalidArgumentError(`The 'remotePath' argument is mandatory`);\n  }\n  if (remotePath.endsWith('/')) {\n    throw new errors.InvalidArgumentError(\n      `It is expected that remote path points to a folder and not to a file. ` +\n      `'${remotePath}' is given instead`\n    );\n  }\n  return await deleteFileOrFolder(this.adb, remotePath);\n};\n\nexport { commands };\nexport default commands;\n"],"mappings":"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"}