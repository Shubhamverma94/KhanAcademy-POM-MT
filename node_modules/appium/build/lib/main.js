#!/usr/bin/env node
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.resolveAppiumHome = exports.init = exports.main = exports.validate = exports.getSchema = exports.finalizeSchema = exports.readConfigFile = void 0;
const logsink_1 = require("./logsink"); // this import needs to come first since it sets up global npmlog
const logger_1 = __importDefault(require("./logger")); // logger needs to remain second
const base_driver_1 = require("@appium/base-driver");
const support_1 = require("@appium/support");
const asyncbox_1 = require("asyncbox");
const lodash_1 = __importDefault(require("lodash"));
const appium_1 = require("./appium");
const extension_1 = require("./cli/extension");
const parser_1 = require("./cli/parser");
const config_1 = require("./config");
const config_file_1 = require("./config-file");
const extension_2 = require("./extension");
const constants_1 = require("./constants");
const grid_register_1 = __importDefault(require("./grid-register"));
const schema_1 = require("./schema/schema");
const utils_1 = require("./utils");
const node_os_1 = __importDefault(require("node:os"));
const { resolveAppiumHome } = support_1.env;
exports.resolveAppiumHome = resolveAppiumHome;
/**
 *
 * @param {ParsedArgs} args
 * @param {boolean} [throwInsteadOfExit]
 */
async function preflightChecks(args, throwInsteadOfExit = false) {
    try {
        (0, config_1.checkNodeOk)();
        await (0, config_1.checkNpmOk)();
        if (args.longStacktrace) {
            Error.stackTraceLimit = constants_1.LONG_STACKTRACE_LIMIT;
        }
        if (args.showBuildInfo) {
            await (0, config_1.showBuildInfo)();
            process.exit(0);
        }
        (0, config_1.warnNodeDeprecations)();
        (0, schema_1.validate)(args);
        if (args.tmpDir) {
            await (0, config_1.validateTmpDir)(args.tmpDir);
        }
    }
    catch (err) {
        logger_1.default.error(err.message.red);
        if (throwInsteadOfExit) {
            throw err;
        }
        process.exit(1);
    }
}
/**
 * @param {Args} args
 */
function logNonDefaultArgsWarning(args) {
    logger_1.default.info('Non-default server args:');
    (0, utils_1.inspect)(args);
}
/**
 * @param {Args['defaultCapabilities']} caps
 */
function logDefaultCapabilitiesWarning(caps) {
    logger_1.default.info('Default capabilities, which will be added to each request ' +
        'unless overridden by desired capabilities:');
    (0, utils_1.inspect)(caps);
}
/**
 * @param {ParsedArgs} args
 */
async function logStartupInfo(args) {
    let welcome = `Welcome to Appium v${config_1.APPIUM_VER}`;
    let appiumRev = await (0, config_1.getGitRev)();
    if (appiumRev) {
        welcome += ` (REV ${appiumRev})`;
    }
    logger_1.default.info(welcome);
    let showArgs = (0, config_1.getNonDefaultServerArgs)(args);
    if (lodash_1.default.size(showArgs)) {
        logNonDefaultArgsWarning(showArgs);
    }
    if (!lodash_1.default.isEmpty(args.defaultCapabilities)) {
        logDefaultCapabilitiesWarning(args.defaultCapabilities);
    }
    // TODO: bring back loglevel reporting below once logger is flushed out
    // logger.info('Console LogLevel: ' + logger.transports.console.level);
    // if (logger.transports.file) {
    //   logger.info('File LogLevel: ' + logger.transports.file.level);
    // }
}
/**
 * Gets a list of `updateServer` functions from all extensions
 * @param {DriverNameMap} driverClasses
 * @param {PluginNameMap} pluginClasses
 * @returns {import('@appium/types').UpdateServerCallback[]}
 */
function getServerUpdaters(driverClasses, pluginClasses) {
    return lodash_1.default.compact(lodash_1.default.map([...driverClasses.keys(), ...pluginClasses.keys()], 'updateServer'));
}
/**
 * Makes a big `MethodMap` from all the little `MethodMap`s in the extensions
 * @param {DriverNameMap} driverClasses
 * @param {PluginNameMap} pluginClasses
 * @returns {import('@appium/types').MethodMap<import('@appium/types').Driver>}
 */
function getExtraMethodMap(driverClasses, pluginClasses) {
    return [...driverClasses.keys(), ...pluginClasses.keys()].reduce((map, klass) => ({
        ...map,
        ...(klass.newMethodMap ?? {}),
    }), {});
}
/**
 * Prepares and validates appium home path folder
 *
 * @param {string} name The name of the appium home source (needed for error messages)
 * @param {string} appiumHome The actual value to be verified
 * @returns {Promise<string>} Same appiumHome value
 * @throws {Error} If the validation has failed
 */
async function prepareAppiumHome(name, appiumHome) {
    let stat;
    try {
        stat = await support_1.fs.stat(appiumHome);
    }
    catch (e) {
        let err = e;
        if (e.code === 'ENOENT') {
            try {
                await support_1.fs.mkdir(appiumHome, { recursive: true });
                return appiumHome;
            }
            catch (e1) {
                err = e1;
            }
        }
        throw new Error(`The path '${appiumHome}' provided in the ${name} must point ` +
            `to a valid folder writeable for the current user account '${node_os_1.default.userInfo().username}'. ` +
            `Original error: ${err.message}`);
    }
    if (!stat.isDirectory()) {
        throw new Error(`The path '${appiumHome}' provided in the ${name} must point to a valid folder`);
    }
    try {
        await support_1.fs.access(appiumHome, support_1.fs.constants.W_OK);
    }
    catch (e) {
        throw new Error(`The folder path '${appiumHome}' provided in the ${name} must be ` +
            `writeable for the current user account '${node_os_1.default.userInfo().username}. ` +
            `Original error: ${e.message}`);
    }
    return appiumHome;
}
/**
 * Initializes Appium, but does not start the server.
 *
 * Use this to get at the configuration schema.
 *
 * If `args` contains a non-empty `subcommand` which is not `server`, this function will return an empty object.
 *
 * @template {CliCommand} [Cmd=ServerCommand]
 * @template {CliExtensionSubcommand|void} [SubCmd=void]
 * @param {Args<Cmd, SubCmd>} [args] - Partial args (progammatic usage only)
 * @returns {Promise<InitResult<Cmd>>}
 * @example
 * import {init, getSchema} from 'appium';
 * const options = {}; // config object
 * await init(options);
 * const schema = getSchema(); // entire config schema including plugins and drivers
 */
async function init(args) {
    const appiumHome = args?.appiumHome ?? (await resolveAppiumHome());
    let appiumHomeSourceName = 'autodetected appium home path';
    if (!lodash_1.default.isNil(args?.appiumHome)) {
        appiumHomeSourceName = 'appiumHome config value';
    }
    else if (process.env.APPIUM_HOME) {
        appiumHomeSourceName = 'APPIUM_HOME environment variable';
    }
    await prepareAppiumHome(appiumHomeSourceName, appiumHome);
    (0, utils_1.adjustNodePath)();
    const { driverConfig, pluginConfig } = await (0, extension_2.loadExtensions)(appiumHome);
    const parser = (0, parser_1.getParser)();
    let throwInsteadOfExit = false;
    /** @type {Args<Cmd, SubCmd>} */
    let preConfigArgs;
    if (args) {
        // if we have a containing package instead of running as a CLI process,
        // that package might not appreciate us calling 'process.exit' willy-
        // nilly, so give it the option to have us throw instead of exit
        if (args.throwInsteadOfExit) {
            throwInsteadOfExit = true;
            // but remove it since it's not a real server arg per se
            delete args.throwInsteadOfExit;
        }
        preConfigArgs = { ...args, subcommand: args.subcommand ?? constants_1.SERVER_SUBCOMMAND };
    }
    else {
        // otherwise parse from CLI
        preConfigArgs = /** @type {Args<Cmd, SubCmd>} */ (parser.parseArgs());
    }
    const configResult = await (0, config_file_1.readConfigFile)(preConfigArgs.configFile);
    if (!lodash_1.default.isEmpty(configResult.errors)) {
        throw new Error(`Errors in config file ${configResult.filepath}:\n ${configResult.reason ?? configResult.errors}`);
    }
    // merge config and apply defaults.
    // the order of precendece is:
    // 1. command line args
    // 2. config file
    // 3. defaults from config file.
    if ((0, utils_1.isServerCommandArgs)(preConfigArgs)) {
        const defaults = (0, schema_1.getDefaultsForSchema)(false);
        /** @type {ParsedArgs} */
        const serverArgs = lodash_1.default.defaultsDeep({}, preConfigArgs, configResult.config?.server, defaults);
        if (preConfigArgs.showConfig) {
            (0, config_1.showConfig)((0, config_1.getNonDefaultServerArgs)(preConfigArgs), configResult, defaults, serverArgs);
            return /** @type {InitResult<Cmd>} */ ({});
        }
        await (0, logsink_1.init)(serverArgs);
        if (serverArgs.logFilters) {
            const { issues, rules } = await support_1.logger.loadSecureValuesPreprocessingRules(serverArgs.logFilters);
            if (!lodash_1.default.isEmpty(issues)) {
                throw new Error(`The log filtering rules config '${serverArgs.logFilters}' has issues: ` +
                    JSON.stringify(issues, null, 2));
            }
            if (lodash_1.default.isEmpty(rules)) {
                logger_1.default.warn(`Found no log filtering rules in '${serverArgs.logFilters}'. Is that expected?`);
            }
            else {
                logger_1.default.info(`Loaded ${support_1.util.pluralize('filtering rule', rules.length, true)} from '${serverArgs.logFilters}'`);
            }
        }
        const appiumDriver = new appium_1.AppiumDriver(
        /** @type {import('@appium/types').DriverOpts<import('./appium').AppiumDriverConstraints>} */ (serverArgs));
        // set the config on the umbrella driver so it can match drivers to caps
        appiumDriver.driverConfig = driverConfig;
        await preflightChecks(serverArgs, throwInsteadOfExit);
        return /** @type {InitResult<Cmd>} */ ({
            appiumDriver,
            parsedArgs: serverArgs,
            driverConfig,
            pluginConfig,
        });
    }
    else {
        if ((0, utils_1.isExtensionCommandArgs)(preConfigArgs)) {
            // if the user has requested the 'driver' CLI, don't run the normal server,
            // but instead pass control to the driver CLI
            if ((0, utils_1.isDriverCommandArgs)(preConfigArgs)) {
                await (0, extension_1.runExtensionCommand)(preConfigArgs, driverConfig);
            }
            if ((0, utils_1.isPluginCommandArgs)(preConfigArgs)) {
                await (0, extension_1.runExtensionCommand)(preConfigArgs, pluginConfig);
            }
        }
        return /** @type {InitResult<Cmd>} */ ({});
    }
}
exports.init = init;
/**
 * Initializes Appium's config.  Starts server if appropriate and resolves the
 * server instance if so; otherwise resolves w/ `undefined`.
 * @template {CliCommand} [Cmd=ServerCommand]
 * @template {CliExtensionSubcommand|void} [SubCmd=void]
 * @param {Args<Cmd, SubCmd>} [args] - Arguments from CLI or otherwise
 * @returns {Promise<Cmd extends ServerCommand ? import('@appium/types').AppiumServer : void>}
 */
async function main(args) {
    const initResult = await init(args);
    if (lodash_1.default.isEmpty(initResult)) {
        // if this branch is taken, we've run a different subcommand, so there's nothing
        // left to do here.
        return /** @type {Cmd extends ServerCommand ? import('@appium/types').AppiumServer : void} */ (undefined);
    }
    const { appiumDriver, pluginConfig, driverConfig, parsedArgs } = 
    /** @type {InitResult<ServerCommand>} */ (initResult);
    const pluginClasses = (0, extension_2.getActivePlugins)(pluginConfig, parsedArgs.usePlugins);
    // set the active plugins on the umbrella driver so it can use them for commands
    appiumDriver.pluginClasses = pluginClasses;
    await logStartupInfo(parsedArgs);
    let routeConfiguringFunction = (0, base_driver_1.routeConfiguringFunction)(appiumDriver);
    const driverClasses = (0, extension_2.getActiveDrivers)(driverConfig, parsedArgs.useDrivers);
    const serverUpdaters = getServerUpdaters(driverClasses, pluginClasses);
    const extraMethodMap = getExtraMethodMap(driverClasses, pluginClasses);
    /** @type {import('@appium/base-driver').ServerOpts} */
    const serverOpts = {
        routeConfiguringFunction,
        port: parsedArgs.port,
        hostname: parsedArgs.address,
        allowCors: parsedArgs.allowCors,
        basePath: parsedArgs.basePath,
        serverUpdaters,
        extraMethodMap,
        cliArgs: parsedArgs,
    };
    if (parsedArgs.keepAliveTimeout) {
        serverOpts.keepAliveTimeout = parsedArgs.keepAliveTimeout * 1000;
    }
    let server;
    try {
        server = await (0, base_driver_1.server)(serverOpts);
    }
    catch (err) {
        logger_1.default.error(`Could not configure Appium server. It's possible that a driver or plugin tried ` +
            `to update the server and failed. Original error: ${err.message}`);
        logger_1.default.debug(err.stack);
        return process.exit(1);
    }
    if (parsedArgs.allowCors) {
        logger_1.default.warn('You have enabled CORS requests from any host. Be careful not ' +
            'to visit sites which could maliciously try to start Appium ' +
            'sessions on your machine');
    }
    appiumDriver.server = server;
    try {
        // configure as node on grid, if necessary
        // falsy values should not cause this to run
        if (parsedArgs.nodeconfig) {
            await (0, grid_register_1.default)(parsedArgs.nodeconfig, parsedArgs.address, parsedArgs.port, parsedArgs.basePath);
        }
    }
    catch (err) {
        await server.close();
        throw err;
    }
    for (const signal of ['SIGINT', 'SIGTERM']) {
        process.once(signal, async function onSignal() {
            logger_1.default.info(`Received ${signal} - shutting down`);
            try {
                await appiumDriver.deleteAllSessions({
                    force: true,
                    reason: `The process has received ${signal} signal`,
                });
                await server.close();
                process.exit(0);
            }
            catch (e) {
                logger_1.default.warn(e);
                process.exit(1);
            }
        });
    }
    logger_1.default.info(`Appium REST http interface listener started on ${parsedArgs.address}:${parsedArgs.port}${parsedArgs.basePath}`);
    driverConfig.print();
    pluginConfig.print([...pluginClasses.values()]);
    return /** @type {Cmd extends ServerCommand ? import('@appium/types').AppiumServer : void} */ (server);
}
exports.main = main;
// NOTE: this is here for backwards compat for any scripts referencing `main.js` directly
// (more specifically, `build/lib/main.js`)
// the executable is now `../index.js`, so that module will typically be `require.main`.
if (require.main === module) {
    (0, asyncbox_1.asyncify)(main);
}
// everything below here is intended to be a public API.
var config_file_2 = require("./config-file");
Object.defineProperty(exports, "readConfigFile", { enumerable: true, get: function () { return config_file_2.readConfigFile; } });
var schema_2 = require("./schema/schema");
Object.defineProperty(exports, "finalizeSchema", { enumerable: true, get: function () { return schema_2.finalizeSchema; } });
Object.defineProperty(exports, "getSchema", { enumerable: true, get: function () { return schema_2.getSchema; } });
Object.defineProperty(exports, "validate", { enumerable: true, get: function () { return schema_2.validate; } });
/**
 * @typedef {import('@appium/types').DriverType} DriverType
 * @typedef {import('@appium/types').PluginType} PluginType
 * @typedef {import('@appium/types').DriverClass} DriverClass
 * @typedef {import('@appium/types').PluginClass} PluginClass
 * @typedef {import('appium/types').CliCommand} CliCommand
 * @typedef {import('appium/types').CliExtensionSubcommand} CliExtensionSubcommand
 * @typedef {import('appium/types').CliExtensionCommand} CliExtensionCommand
 * @typedef {import('appium/types').CliCommandServer} ServerCommand
 * @typedef {import('appium/types').CliCommandDriver} DriverCommand
 * @typedef {import('appium/types').CliCommandPlugin} PluginCommand
 * @typedef {import('./extension').DriverNameMap} DriverNameMap
 * @typedef {import('./extension').PluginNameMap} PluginNameMap
 */
/**
 * Literally an empty object
 * @typedef { {} } ExtCommandInitResult
 */
/**
 * @typedef ServerInitData
 * @property {import('./appium').AppiumDriver} appiumDriver - The Appium driver
 * @property {import('appium/types').ParsedArgs} parsedArgs - The parsed arguments
 */
/**
 * @template {CliCommand} Cmd
 * @typedef {Cmd extends ServerCommand ? ServerInitData & import('./extension').ExtensionConfigs : ExtCommandInitResult} InitResult
 */
/**
 * @template {CliCommand} [Cmd=ServerCommand]
 * @template {CliExtensionSubcommand|void} [SubCmd=void]
 * @typedef {import('appium/types').Args<Cmd, SubCmd>} Args
 */
/**
 * @template {CliCommand} [Cmd=ServerCommand]
 * @template {CliExtensionSubcommand|void} [SubCmd=void]
 * @typedef {import('appium/types').ParsedArgs<Cmd, SubCmd>} ParsedArgs
 */
//# sourceMappingURL=main.js.map