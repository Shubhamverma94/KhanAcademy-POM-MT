"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.load = void 0;
const typedoc_1 = require("typedoc");
const path_1 = require("path");
const fs_1 = require("fs");
function load(app) {
    const fileNameToModule = new Map();
    app.converter.on(typedoc_1.Converter.EVENT_RESOLVE, (context, reflection) => visitReflection(context.project, reflection, fileNameToModule));
}
exports.load = load;
function visitReflection(project, reflection, fileNameToModule) {
    if (isTypedReflection(reflection)) {
        recursivelyFixTyped(project, reflection, 'type', fileNameToModule);
    }
    if (reflection instanceof typedoc_1.DeclarationReflection) {
        recursivelyFixTyped(project, reflection, 'extendedTypes', fileNameToModule);
        recursivelyFixTyped(project, reflection, 'implementedTypes', fileNameToModule);
    }
    if (reflection instanceof typedoc_1.TypeParameterReflection) {
        recursivelyFixTyped(project, reflection, 'default', fileNameToModule);
    }
}
function recursivelyFixTyped(project, typed, f, fileNameToModule) {
    fixTyped(project, typed, f, fileNameToModule);
    const typedField = typed[f];
    if (!typedField)
        return;
    const visitor = (0, typedoc_1.makeRecursiveVisitor)({
        array(type) {
            fixTyped(project, type, 'elementType', fileNameToModule);
        },
        conditional(type) {
            fixTyped(project, type, 'checkType', fileNameToModule);
            fixTyped(project, type, 'trueType', fileNameToModule);
            fixTyped(project, type, 'falseType', fileNameToModule);
            fixTyped(project, type, 'extendsType', fileNameToModule);
        },
        indexedAccess(type) {
            fixTyped(project, type, 'indexType', fileNameToModule);
            fixTyped(project, type, 'objectType', fileNameToModule);
        },
        intersection(type) {
            fixTyped(project, type, 'types', fileNameToModule);
        },
        mapped(type) {
            fixTyped(project, type, 'nameType', fileNameToModule);
            fixTyped(project, type, 'parameterType', fileNameToModule);
            fixTyped(project, type, 'templateType', fileNameToModule);
        },
        'named-tuple-member'(type) {
            fixTyped(project, type, 'element', fileNameToModule);
        },
        optional(type) {
            fixTyped(project, type, 'elementType', fileNameToModule);
        },
        predicate(type) {
            fixTyped(project, type, 'targetType', fileNameToModule);
        },
        query(type) {
            fixTyped(project, type, 'queryType', fileNameToModule);
        },
        reference(type) {
            fixTyped(project, type, 'typeArguments', fileNameToModule);
        },
        reflection(type) {
            fixTyped(project, type.declaration, 'type', fileNameToModule);
        },
        rest(type) {
            fixTyped(project, type, 'elementType', fileNameToModule);
        },
        tuple(type) {
            fixTyped(project, type, 'elements', fileNameToModule);
        },
        // FIXME template-literal?
        typeOperator(type) {
            fixTyped(project, type, 'target', fileNameToModule);
        },
        union(type) {
            fixTyped(project, type, 'types', fileNameToModule);
        },
    });
    if (Array.isArray(typedField)) {
        typedField.forEach((type) => type.visit(visitor));
    }
    else {
        typedField.visit(visitor);
    }
}
function fixTyped(project, typed, field, fileNameToModule) {
    const typedField = typed[field];
    if (!typedField)
        return;
    if (Array.isArray(typedField)) {
        typedField.forEach((iType, i) => {
            typedField[i] = fixType(project, iType, fileNameToModule);
        });
    }
    else {
        typed[field] = fixType(project, typedField, fileNameToModule);
    }
}
function fixType(project, type, fileNameToModule) {
    if (isReferenceType(type) && isReferenceTypeBroken(type))
        return findReferenceType(type, project, fileNameToModule);
    return type;
}
function findReferenceType(type, project, fileNameToModule) {
    const fileName = type.getSymbol()?.getDeclarations()?.[0].getSourceFile().fileName;
    if (!fileName)
        return type;
    let module;
    if (fileNameToModule.has(fileName)) {
        module = fileNameToModule.get(fileName);
    }
    else {
        const moduleFilePath = findModuleFilePath(fileName);
        if (!moduleFilePath)
            return type;
        const moduleConfig = JSON.parse((0, fs_1.readFileSync)(moduleFilePath).toString('utf8'));
        // Ideally we wouldn't use typedoc's displayName and look for the module by originalName
        // But typedoc sets originalName to the same value as displayName...
        const moduleName = moduleConfig?.typedoc?.displayName ?? moduleConfig.name;
        module = project.getChildrenByKind(typedoc_1.ReflectionKind.Module).find(({ name }) => moduleName === name);
        fileNameToModule.set(fileName, module);
    }
    if (!module)
        return type;
    const newTarget = module.getChildByName(type.qualifiedName);
    if (!newTarget)
        return type;
    const newType = typedoc_1.ReferenceType.createResolvedReference(type.name, newTarget, project);
    newType.typeArguments = type.typeArguments;
    return newType;
}
function findModuleFilePath(path) {
    const dir = (0, path_1.dirname)(path);
    if (dir === path)
        return undefined;
    const moduleFilePath = (0, path_1.join)(dir, 'package.json');
    if ((0, fs_1.existsSync)(moduleFilePath))
        return moduleFilePath;
    return findModuleFilePath(dir);
}
function isReferenceType(type) {
    return type.type === 'reference';
}
function isReferenceTypeBroken(type) {
    return type.reflection == null && type.getSymbol() != null;
}
function isTypedReflection(reflection) {
    return (reflection instanceof typedoc_1.DeclarationReflection ||
        reflection instanceof typedoc_1.SignatureReflection ||
        reflection instanceof typedoc_1.ParameterReflection ||
        reflection instanceof typedoc_1.TypeParameterReflection);
}
